{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"ThankYou/","text":"The Tribute DAO Framework was conceived based on the solid and foundational work done by our team, MolochVentures , and Meta Cartel in MolochV2 . This framework extends the MolochV2 contracts to create a DAO framework with new features and modularity in mind. It was only possible to design, and implement such a solution because great precursors have opened the path forward with the release of MolochV2 . Because of that, we want to say THANK YOU to all coders, designers, auditors, and any individual who have contributed with ideas, resources, and energy to this and previous versions of this project. Thanks for helping to shape the DAO open source ecosystem, and a special thank you to MolochV2 creators/contributors: Ameen Soleimani Rahul Sethuram Andy Gray Heiko Fisch James Young Patricio Palladino Dao Designer James Morgan Vincent Santiago Siri Ross Campbell Eric Olszewski Arjun Bhuptani Jorge Izquierdo Lautaro Ezequiel Dragan Peter Grassberger Burrrata Thank you to all Tribute DAO Framework contributors: Benjamin Patch Dimitris Kyriazopoulos Thank you to all auditors from: ConsenSys Diligence Thank you to all maintainers and supporters of the amazing Open Source tooling and development libraries for the Web3: EthereumJS ChainSafe MetaMask Nomic Labs OpenZeppelin Truffle Suite p.s.: feel free to submit a PR with your name added to the list, if we missed any .","title":"ThankYou"},{"location":"adapters/BatchVoting/","text":"BatchVoting description and scope This is another voting adapter that uses the same format used in OffchainVoting but instead of computing the result offchain is doing all the work on chain. This means that the gas cost is O(nb votes) but does not need any challenge mechanism. Adapter workflow The workflow is the same as for Offchain voting minus the challenge part. startNewVotingForProposal starts a voting session Then all the votes happen offchain in snapshot Once the votes are done, the client prepares a list of all the votes and sends it to submitVoteResult While processing the votes we check that: the signature is correct the vote was for this particular proposal the member addresses are in order and with no duplicate From there, the vote enters grace period if potential new votes could change the result and just resolves the vote otherwise. Adapter configuration the two configurations for BatchVoting are Voting period & Grace period Adapter state The adapter keeps track of each vote \"session\" for each dao & proposalId. The session has the following properties: uint256 snapshot what snapshot (block number) is used for this vote uint256 nbYes how many yes votes have been reported uint256 nbNo how many no votes have been reported address actionId which actionId (adapter address) has created the vote session bytes32 proposalHash the proposal hash uint256 startingTime when did the vote start uint256 gracePeriodStartingTime when did we enter the grace period Dependencies and interactions (internal / external) BatchVoting interacts with Bank extension and DaoRegistry to get information about the member voting. The info is: its delegate key at the time of voting how many units does the member have Functions description and assumptions / checks Describe the public and private functions signatures with proper documentation and clearly explain what each function does. Specify what are expected the arguments and pre-conditions to execute the functions. Also, provide what is the expected outcome. Examples: function submitVoteResult(DaoRegistry dao, bytes32 proposalId, VoteEntry[] memory votes) this function submits a vote result for a certain proposal. It first processes the votes If the result has more weight than the previous one and the vote is still going on, update the result If the result has changed from before (pass -> fail or fail -> pass), update the start of grace period to now function getAdapterName() returns the voting adapter name \"BatchVotingContract\" function processVotes(DaoRegistry dao, bytes32 proposalId, VoteEntry[] memory entries) Process all the votes. For each entry, it validates the vote and then computes the result. function validateVote(DaoRegistry dao, BankExtension bank, address actionId, uint256 snapshot, bytes32 proposalHash, address previousAddress, VoteEntry memory entry) It validates the vote entry. It does the following checks: checks that the memberAddress is the one who signed the vote (or its delegate key) checks that the previous member address is \"before\" (hex order) the current one checks that the vote is actually for this proposal If it is all good, returns the amount of units the member has at that point in time function getSenderAddress(DaoRegistry dao, address actionId, bytes memory data,address) returns the address that has signed the proposal hash function startNewVotingForProposal(DaoRegistry dao, bytes32 proposalId, bytes memory data) Starts a new voting session. It first decode the proposal data, then builds the proposal hash. From there, it checks that the signature is for this hash and from an active member. It also checks that the block number is not 0 and is not in the future if all checks out, we write the actionId (msg.sender), startingTime (block.timestamp), snapshot and proposal hash into the voting session struct function voteResult(DaoRegistry dao, bytes32 proposalId) returns the vote status. Events NewVoteResult(address dao, address actionId, uint256 nbYes, uint256 nbNo) is emitted when a new vote result has been submitted","title":"BatchVoting"},{"location":"adapters/BatchVoting/#batchvoting-description-and-scope","text":"This is another voting adapter that uses the same format used in OffchainVoting but instead of computing the result offchain is doing all the work on chain. This means that the gas cost is O(nb votes) but does not need any challenge mechanism.","title":"BatchVoting description and scope"},{"location":"adapters/BatchVoting/#adapter-workflow","text":"The workflow is the same as for Offchain voting minus the challenge part. startNewVotingForProposal starts a voting session Then all the votes happen offchain in snapshot Once the votes are done, the client prepares a list of all the votes and sends it to submitVoteResult While processing the votes we check that: the signature is correct the vote was for this particular proposal the member addresses are in order and with no duplicate From there, the vote enters grace period if potential new votes could change the result and just resolves the vote otherwise.","title":"Adapter workflow"},{"location":"adapters/BatchVoting/#adapter-configuration","text":"the two configurations for BatchVoting are Voting period & Grace period","title":"Adapter configuration"},{"location":"adapters/BatchVoting/#adapter-state","text":"The adapter keeps track of each vote \"session\" for each dao & proposalId. The session has the following properties: uint256 snapshot what snapshot (block number) is used for this vote uint256 nbYes how many yes votes have been reported uint256 nbNo how many no votes have been reported address actionId which actionId (adapter address) has created the vote session bytes32 proposalHash the proposal hash uint256 startingTime when did the vote start uint256 gracePeriodStartingTime when did we enter the grace period","title":"Adapter state"},{"location":"adapters/BatchVoting/#dependencies-and-interactions-internal-external","text":"BatchVoting interacts with Bank extension and DaoRegistry to get information about the member voting. The info is: its delegate key at the time of voting how many units does the member have","title":"Dependencies and interactions (internal / external)"},{"location":"adapters/BatchVoting/#functions-description-and-assumptions-checks","text":"Describe the public and private functions signatures with proper documentation and clearly explain what each function does. Specify what are expected the arguments and pre-conditions to execute the functions. Also, provide what is the expected outcome. Examples:","title":"Functions description and assumptions / checks"},{"location":"adapters/BatchVoting/#function-submitvoteresultdaoregistry-dao-bytes32-proposalid-voteentry-memory-votes","text":"this function submits a vote result for a certain proposal. It first processes the votes If the result has more weight than the previous one and the vote is still going on, update the result If the result has changed from before (pass -> fail or fail -> pass), update the start of grace period to now","title":"function submitVoteResult(DaoRegistry dao, bytes32 proposalId, VoteEntry[] memory votes)"},{"location":"adapters/BatchVoting/#function-getadaptername","text":"returns the voting adapter name \"BatchVotingContract\"","title":"function getAdapterName()"},{"location":"adapters/BatchVoting/#function-processvotesdaoregistry-dao-bytes32-proposalid-voteentry-memory-entries","text":"Process all the votes. For each entry, it validates the vote and then computes the result.","title":"function processVotes(DaoRegistry dao, bytes32 proposalId, VoteEntry[] memory entries)"},{"location":"adapters/BatchVoting/#function-validatevotedaoregistry-dao-bankextension-bank-address-actionid-uint256-snapshot-bytes32-proposalhash-address-previousaddress-voteentry-memory-entry","text":"It validates the vote entry. It does the following checks: checks that the memberAddress is the one who signed the vote (or its delegate key) checks that the previous member address is \"before\" (hex order) the current one checks that the vote is actually for this proposal If it is all good, returns the amount of units the member has at that point in time","title":"function validateVote(DaoRegistry dao, BankExtension bank, address actionId, uint256 snapshot, bytes32 proposalHash, address previousAddress, VoteEntry memory entry)"},{"location":"adapters/BatchVoting/#function-getsenderaddressdaoregistry-dao-address-actionid-bytes-memory-dataaddress","text":"returns the address that has signed the proposal hash","title":"function getSenderAddress(DaoRegistry dao, address actionId, bytes memory data,address)"},{"location":"adapters/BatchVoting/#function-startnewvotingforproposaldaoregistry-dao-bytes32-proposalid-bytes-memory-data","text":"Starts a new voting session. It first decode the proposal data, then builds the proposal hash. From there, it checks that the signature is for this hash and from an active member. It also checks that the block number is not 0 and is not in the future if all checks out, we write the actionId (msg.sender), startingTime (block.timestamp), snapshot and proposal hash into the voting session struct","title":"function startNewVotingForProposal(DaoRegistry dao, bytes32 proposalId, bytes memory data)"},{"location":"adapters/BatchVoting/#function-voteresultdaoregistry-dao-bytes32-proposalid","text":"returns the vote status.","title":"function voteResult(DaoRegistry dao, bytes32 proposalId)"},{"location":"adapters/BatchVoting/#events","text":"","title":"Events"},{"location":"adapters/BatchVoting/#newvoteresultaddress-dao-address-actionid-uint256-nbyes-uint256-nbno","text":"is emitted when a new vote result has been submitted","title":"NewVoteResult(address dao, address actionId, uint256 nbYes, uint256 nbNo)"},{"location":"adapters/Configuration/","text":"Adapter description and scope The Configuration adapter manages storing and retrieving per-DAO settings required by shared adapters. Some adapters have configurable settings which must be stored for each DAO instance that uses the shared adapter. Workflows Submit proposal check that caller is valid member check that keys/values are same length check that proposalId is unique submit proposal to DAO create and store configuration structure Sponsor module change request check that caller is valid member initiate vote Process proposal check that caller is valid member check that proposalId exists check that proposal passed for each key and value, set it in the configuration for this DAO process proposal Adapter state The adapter stores the proposed configuration changes. Configuration DAORegistry Access Flags: SUBMIT_PROPOSAL , SET_CONFIGURATION . keys The array of keys to set in the configuration. values The array of values to set in the configuration. Dependencies and interactions (internal / external) Functions description and assumptions / checks function submitProposal(DaoRegistry dao, bytes32 proposalId, bytes32[] calldata keys, uint256[] calldata values, bytes calldata data) Creates and sponsors a new configuration proposal on behalf of the member calling the function. dao is the DAO instance to be configured proposalId is the ID chosen for this configuration proposal, must be unique keys the configuration keys to set values the configuration values to set, must be same length as keys data function processProposal(DaoRegistry dao, bytes32 proposalId) Processes a previously created configuration proposal by applying the configuration to the DAO. dao is the DAO instance to be configured proposalId is the ID of a previously created and sponsored configuration proposal which has passed the vote","title":"Configuration"},{"location":"adapters/Configuration/#adapter-description-and-scope","text":"The Configuration adapter manages storing and retrieving per-DAO settings required by shared adapters. Some adapters have configurable settings which must be stored for each DAO instance that uses the shared adapter.","title":"Adapter description and scope"},{"location":"adapters/Configuration/#workflows","text":"Submit proposal check that caller is valid member check that keys/values are same length check that proposalId is unique submit proposal to DAO create and store configuration structure Sponsor module change request check that caller is valid member initiate vote Process proposal check that caller is valid member check that proposalId exists check that proposal passed for each key and value, set it in the configuration for this DAO process proposal","title":"Workflows"},{"location":"adapters/Configuration/#adapter-state","text":"The adapter stores the proposed configuration changes.","title":"Adapter state"},{"location":"adapters/Configuration/#configuration","text":"DAORegistry Access Flags: SUBMIT_PROPOSAL , SET_CONFIGURATION .","title":"Configuration"},{"location":"adapters/Configuration/#keys","text":"The array of keys to set in the configuration.","title":"keys"},{"location":"adapters/Configuration/#values","text":"The array of values to set in the configuration.","title":"values"},{"location":"adapters/Configuration/#dependencies-and-interactions-internal-external","text":"","title":"Dependencies and interactions (internal / external)"},{"location":"adapters/Configuration/#functions-description-and-assumptions-checks","text":"","title":"Functions description and assumptions / checks"},{"location":"adapters/Configuration/#function-submitproposaldaoregistry-dao-bytes32-proposalid-bytes32-calldata-keys-uint256-calldata-values-bytes-calldata-data","text":"Creates and sponsors a new configuration proposal on behalf of the member calling the function. dao is the DAO instance to be configured proposalId is the ID chosen for this configuration proposal, must be unique keys the configuration keys to set values the configuration values to set, must be same length as keys data","title":"function submitProposal(DaoRegistry dao, bytes32 proposalId, bytes32[] calldata keys, uint256[] calldata values, bytes calldata data)"},{"location":"adapters/Configuration/#function-processproposaldaoregistry-dao-bytes32-proposalid","text":"Processes a previously created configuration proposal by applying the configuration to the DAO. dao is the DAO instance to be configured proposalId is the ID of a previously created and sponsored configuration proposal which has passed the vote","title":"function processProposal(DaoRegistry dao, bytes32 proposalId)"},{"location":"adapters/CouponOnboarding/","text":"Adapter description and scope The CouponOnboarding adapter provides a way to onboard an initial group of members quickly without requiring multiple proposals. The DAO creator can produce and sign coupons which allow redemption of a particular number of units by a given address. When the coupon is redeemed the units are directly issued to the new member. Adapter workflow Redeem coupon request check that the coupon has not already been redeemed check that the signed hash matches the hash of the redeem arguments check that the signer of the coupon matches the configured signer mint the configured tokens to the new member mark the coupon redeemed Adapter configuration DAORegistry Access Flags: NEW_MEMBER . Bank Extension Access Flags: ADD_TO_BALANCE . signerAddress The public address of the signer key used to generate coupons for this adapter. tokenAddrToMint The address of the token that will be created and issued to the address in the redeemed coupons. Adapter state Coupon The coupon structure contains the data fields necessary to redeem and add a new member. authorizedMember The address that this coupon authorized to become a new member. amount The amount of units that this member will receive. nonce A unique identifier for this coupon request. Dependencies and interactions (internal / external) Functions description and assumptions / checks function hashCouponMessage(DaoRegistry dao, Coupon memory coupon) public view returns (bytes32) Hashes the provided coupon as an ERC712 hash. dao is the DAO instance to be configured coupon is the coupon to hash function redeemCoupon(DaoRegistry dao, address authorizedMember, uint256 amount, uint256 nonce, bytes memory signature) external Redeems a coupon to add a new member. dao is the DAO instance to be configured authorizedMember is the address that this coupon authorized to become a new member. amount is the amount of units that this member will receive. nonce is a unique identifier for this coupon request.","title":"CouponOnboarding"},{"location":"adapters/CouponOnboarding/#adapter-description-and-scope","text":"The CouponOnboarding adapter provides a way to onboard an initial group of members quickly without requiring multiple proposals. The DAO creator can produce and sign coupons which allow redemption of a particular number of units by a given address. When the coupon is redeemed the units are directly issued to the new member.","title":"Adapter description and scope"},{"location":"adapters/CouponOnboarding/#adapter-workflow","text":"Redeem coupon request check that the coupon has not already been redeemed check that the signed hash matches the hash of the redeem arguments check that the signer of the coupon matches the configured signer mint the configured tokens to the new member mark the coupon redeemed","title":"Adapter workflow"},{"location":"adapters/CouponOnboarding/#adapter-configuration","text":"DAORegistry Access Flags: NEW_MEMBER . Bank Extension Access Flags: ADD_TO_BALANCE .","title":"Adapter configuration"},{"location":"adapters/CouponOnboarding/#signeraddress","text":"The public address of the signer key used to generate coupons for this adapter.","title":"signerAddress"},{"location":"adapters/CouponOnboarding/#tokenaddrtomint","text":"The address of the token that will be created and issued to the address in the redeemed coupons.","title":"tokenAddrToMint"},{"location":"adapters/CouponOnboarding/#adapter-state","text":"","title":"Adapter state"},{"location":"adapters/CouponOnboarding/#coupon","text":"The coupon structure contains the data fields necessary to redeem and add a new member.","title":"Coupon"},{"location":"adapters/CouponOnboarding/#authorizedmember","text":"The address that this coupon authorized to become a new member.","title":"authorizedMember"},{"location":"adapters/CouponOnboarding/#amount","text":"The amount of units that this member will receive.","title":"amount"},{"location":"adapters/CouponOnboarding/#nonce","text":"A unique identifier for this coupon request.","title":"nonce"},{"location":"adapters/CouponOnboarding/#dependencies-and-interactions-internal-external","text":"","title":"Dependencies and interactions (internal / external)"},{"location":"adapters/CouponOnboarding/#functions-description-and-assumptions-checks","text":"","title":"Functions description and assumptions / checks"},{"location":"adapters/CouponOnboarding/#function-hashcouponmessagedaoregistry-dao-coupon-memory-coupon-public-view-returns-bytes32","text":"Hashes the provided coupon as an ERC712 hash. dao is the DAO instance to be configured coupon is the coupon to hash","title":"function hashCouponMessage(DaoRegistry dao, Coupon memory coupon) public view returns (bytes32)"},{"location":"adapters/CouponOnboarding/#function-redeemcoupondaoregistry-dao-address-authorizedmember-uint256-amount-uint256-nonce-bytes-memory-signature-external","text":"Redeems a coupon to add a new member. dao is the DAO instance to be configured authorizedMember is the address that this coupon authorized to become a new member. amount is the amount of units that this member will receive. nonce is a unique identifier for this coupon request.","title":"function redeemCoupon(DaoRegistry dao, address authorizedMember, uint256 amount, uint256 nonce, bytes memory signature) external"},{"location":"adapters/Distribute/","text":"Adapter description and scope The Distribute Adapter provides features in which the DAO members can receive funds from the DAO for any given reason. A good example of that is when the members collectively agree to payout dividends to one or all member of the DAO, when that happens they can submit a proposal for voting, and if the proposal pass the amount is distributed equally to the members. Adapter workflow The token distribution starts when a member submits a proposal to distribute a certain amount of a token for one or all members of the DAO. It is important to mention that the distribution can only happen for 1 member or for all, there is no way to distribute the tokens for a subset of the DAO members. Once the distribution proposal gets created, it is open for voting, and sponsored by the message sender. The adapter tracks all the distributions that have been executed already by each DAO, and also tracks the current distributions that is in progress - this is done to ensure the distributions are executed sequentially per DAO. Once the distribution proposal has passed, the other members have to start the actual distribution process (function processProposal ). In this process the member indicated in the proposal or each member of the DAO will receive, based on the current number of holding units, a token amount in the internal bank account, so it can be withdraw later on. This process does not changes the number of units of the members, it just uses it to calculate the fair amount to distribute for each member. After that, the distribution proposal gets updated to Completed . Adapter configuration The member needs to have at least 1 unit to be able to receive funds from a distribution proposal. DAORegistry Access Flags: SUBMIT_PROPOSAL . Bank Extension Access Flags: INTERNAL_TRANSFER . Adapter state DistributionStatus : The distribution status ( Not Started , In Progress , Done ). Distribution : State of the proposal. token : The distribution token in which the members should receive the funds. Must be supported by the DAO. amount : The amount to distribute. status : The distribution status. unitHolderAddr : The member address that should receive the funds, if 0x0, the funds will be distributed to all members of the DAO. currentIndex : Current iteration index to control the cached for-loop. blockNumber : The block number in which the proposal has been created. distributions : Keeps track of all the distributions executed per DAO. ongoingDistributions : Keeps track of the latest ongoing distribution proposal per DAO to ensure only 1 proposal can be processed at a time. Dependencies and interactions (internal / external) BankExtension transfers the funds from the DAO account to the member's account. gets the available tokens. gets the historical balance of the guild account. DaoRegistry checks if the message sender is actually a member of the DAO. checks if the unit holder is actually a member of the DAO. process the distribution proposal. Voting starts a new voting for the distribution proposal. checks the voting results. FairShareHelper to calculate the amount of funds to be distributed to the member based on the current number of units of the member - taking into account the historical balance of the GUILD. Functions description and assumptions / checks receive() external payable /** * @notice default fallback function to prevent from sending ether to the contract. */ receive() external payable function submitProposal /** * @notice Creates a distribution proposal for one or all members of the DAO, opens it for voting, and sponsors it. * @dev Only tokens that are allowed by the Bank are accepted. * @dev If the unitHolderAddr is 0x0, then the funds will be distributed to all members of the DAO. * @dev Proposal ids can not be reused. * @dev The amount must be greater than zero. * @param dao The dao address. * @param proposalId The distribution proposal id. * @param unitHolderAddr The member address that should receive the funds, if 0x0, the funds will be distributed to all members of the DAO. * @param token The distribution token in which the members should receive the funds. Must be supported by the DAO. * @param amount The amount to distribute. * @param data Additional information related to the distribution proposal. */ function submitProposal( DaoRegistry dao, bytes32 proposalId, address unitHolderAddr, address token, int256 amount, bytes calldata data ) external _submitProposal /** * @notice Creates the proposal, starts the voting process and sponsors the proposal. * @dev If the unit holder address was provided in the params, the unit holder must have enough units to receive the funds. */ function _submitProposal( DaoRegistry dao, bytes32 proposalId, address unitHolderAddr, address token, uint256 amount, bytes calldata data, address submittedBy ) internal onlyMember2(dao, submittedBy) processProposal /** * @notice Process the distribution proposal, calculates the fair amount of funds to distribute to the members based on the units holdings. * @dev A distribution proposal must be in progress. * @dev Only one proposal per DAO can be executed at time. * @dev Only active members can receive funds. * @dev Only proposals that passed the voting can be set to In Progress status. * @param dao The dao address. * @param proposalId The distribution proposal id. */ function processProposal(DaoRegistry dao, bytes32 proposalId) external distribute /** * @notice Transfers the funds from the Guild account to the member's internal accounts. * @notice The amount of funds is caculated using the historical number of units of each member. * @dev A distribution proposal must be in progress. * @dev Only proposals that have passed the voting can be completed. * @dev Only active members can receive funds. * @param dao The dao address. * @param toIndex The index to control the cached for-loop. */ function distribute(DaoRegistry dao, uint256 toIndex) external override Events When the distribution process is completed the Distributed event is emitted with the token , amount , and unitHolder parameters. If the unitHolder is 0x0 , the amount was distributed to all members of the DAO, otherwise it was distributed to the unit holder only.","title":"Distribute"},{"location":"adapters/Distribute/#adapter-description-and-scope","text":"The Distribute Adapter provides features in which the DAO members can receive funds from the DAO for any given reason. A good example of that is when the members collectively agree to payout dividends to one or all member of the DAO, when that happens they can submit a proposal for voting, and if the proposal pass the amount is distributed equally to the members.","title":"Adapter description and scope"},{"location":"adapters/Distribute/#adapter-workflow","text":"The token distribution starts when a member submits a proposal to distribute a certain amount of a token for one or all members of the DAO. It is important to mention that the distribution can only happen for 1 member or for all, there is no way to distribute the tokens for a subset of the DAO members. Once the distribution proposal gets created, it is open for voting, and sponsored by the message sender. The adapter tracks all the distributions that have been executed already by each DAO, and also tracks the current distributions that is in progress - this is done to ensure the distributions are executed sequentially per DAO. Once the distribution proposal has passed, the other members have to start the actual distribution process (function processProposal ). In this process the member indicated in the proposal or each member of the DAO will receive, based on the current number of holding units, a token amount in the internal bank account, so it can be withdraw later on. This process does not changes the number of units of the members, it just uses it to calculate the fair amount to distribute for each member. After that, the distribution proposal gets updated to Completed .","title":"Adapter workflow"},{"location":"adapters/Distribute/#adapter-configuration","text":"The member needs to have at least 1 unit to be able to receive funds from a distribution proposal. DAORegistry Access Flags: SUBMIT_PROPOSAL . Bank Extension Access Flags: INTERNAL_TRANSFER .","title":"Adapter configuration"},{"location":"adapters/Distribute/#adapter-state","text":"DistributionStatus : The distribution status ( Not Started , In Progress , Done ). Distribution : State of the proposal. token : The distribution token in which the members should receive the funds. Must be supported by the DAO. amount : The amount to distribute. status : The distribution status. unitHolderAddr : The member address that should receive the funds, if 0x0, the funds will be distributed to all members of the DAO. currentIndex : Current iteration index to control the cached for-loop. blockNumber : The block number in which the proposal has been created. distributions : Keeps track of all the distributions executed per DAO. ongoingDistributions : Keeps track of the latest ongoing distribution proposal per DAO to ensure only 1 proposal can be processed at a time.","title":"Adapter state"},{"location":"adapters/Distribute/#dependencies-and-interactions-internal-external","text":"BankExtension transfers the funds from the DAO account to the member's account. gets the available tokens. gets the historical balance of the guild account. DaoRegistry checks if the message sender is actually a member of the DAO. checks if the unit holder is actually a member of the DAO. process the distribution proposal. Voting starts a new voting for the distribution proposal. checks the voting results. FairShareHelper to calculate the amount of funds to be distributed to the member based on the current number of units of the member - taking into account the historical balance of the GUILD.","title":"Dependencies and interactions (internal / external)"},{"location":"adapters/Distribute/#functions-description-and-assumptions-checks","text":"","title":"Functions description and assumptions / checks"},{"location":"adapters/Distribute/#receive-external-payable","text":"/** * @notice default fallback function to prevent from sending ether to the contract. */ receive() external payable","title":"receive() external payable"},{"location":"adapters/Distribute/#function-submitproposal","text":"/** * @notice Creates a distribution proposal for one or all members of the DAO, opens it for voting, and sponsors it. * @dev Only tokens that are allowed by the Bank are accepted. * @dev If the unitHolderAddr is 0x0, then the funds will be distributed to all members of the DAO. * @dev Proposal ids can not be reused. * @dev The amount must be greater than zero. * @param dao The dao address. * @param proposalId The distribution proposal id. * @param unitHolderAddr The member address that should receive the funds, if 0x0, the funds will be distributed to all members of the DAO. * @param token The distribution token in which the members should receive the funds. Must be supported by the DAO. * @param amount The amount to distribute. * @param data Additional information related to the distribution proposal. */ function submitProposal( DaoRegistry dao, bytes32 proposalId, address unitHolderAddr, address token, int256 amount, bytes calldata data ) external","title":"function submitProposal"},{"location":"adapters/Distribute/#_submitproposal","text":"/** * @notice Creates the proposal, starts the voting process and sponsors the proposal. * @dev If the unit holder address was provided in the params, the unit holder must have enough units to receive the funds. */ function _submitProposal( DaoRegistry dao, bytes32 proposalId, address unitHolderAddr, address token, uint256 amount, bytes calldata data, address submittedBy ) internal onlyMember2(dao, submittedBy)","title":"_submitProposal"},{"location":"adapters/Distribute/#processproposal","text":"/** * @notice Process the distribution proposal, calculates the fair amount of funds to distribute to the members based on the units holdings. * @dev A distribution proposal must be in progress. * @dev Only one proposal per DAO can be executed at time. * @dev Only active members can receive funds. * @dev Only proposals that passed the voting can be set to In Progress status. * @param dao The dao address. * @param proposalId The distribution proposal id. */ function processProposal(DaoRegistry dao, bytes32 proposalId) external","title":"processProposal"},{"location":"adapters/Distribute/#distribute","text":"/** * @notice Transfers the funds from the Guild account to the member's internal accounts. * @notice The amount of funds is caculated using the historical number of units of each member. * @dev A distribution proposal must be in progress. * @dev Only proposals that have passed the voting can be completed. * @dev Only active members can receive funds. * @param dao The dao address. * @param toIndex The index to control the cached for-loop. */ function distribute(DaoRegistry dao, uint256 toIndex) external override","title":"distribute"},{"location":"adapters/Distribute/#events","text":"When the distribution process is completed the Distributed event is emitted with the token , amount , and unitHolder parameters. If the unitHolder is 0x0 , the amount was distributed to all members of the DAO, otherwise it was distributed to the unit holder only.","title":"Events"},{"location":"adapters/Financing/","text":"Adapter description and scope Financing is the process in which an applicant, member or a non-member of the DAO, submits a proposal asking for funds. If the proposal passes, the funds are released to the applicant. The main goal is to allow individuals and/or organizations to request funds to finance their projects, and the members of the DAO have the power to vote and decide which projects should be funded. Adapter workflow In order to request funds from the DAO, the applicant must submit a proposal in which one must specify the desired amount and the token address to receive the funds. The applicant address cannot be a reserved address, which means the address is already reserved for the DAO internal usage. Also, the token address must be allowed/supported by the DAO Bank. If these two conditions are not met, the funding proposal is not created. Adapter configuration Tokens that are provided by the member have to be allowed/supported by the DAO. The member needs to have enough units and/or loot in order to convert it to funds. DAORegistry Access Flags: SUBMIT_PROPOSAL . Bank Extension Access Flags: ADD_TO_BALANCE , SUB_FROM_BALANCE . Adapter state proposals : all financing proposals handled by each DAO. ProposalDetails : applicant : the proposal applicant address, cannot be a reserved address. amount : the amount requested for funding. token : the token address in which the funding is made to the applicant, needs to be allowed/supported by the DAO Bank. Dependencies and interactions (internal / external) BankExtension checks if the provided token is allowed/supported by the Bank. subtracts from Guild balance the requested amount based on the provided token. adds to the applicant account the subtracted amount based on the provided token. DaoRegistry gets Bank extension address. checks if member address is not reserved. submits/sponsors/processes the financing proposal. gets Voting adapter address. Voting gets address that sent the sponsorProposal transaction. starts new voting for the financing proposal. checks the voting results. Functions description and assumptions / checks receive() external payable /** * @notice default fallback function to prevent from sending ether to the contract. */ receive() external payable function submitProposal /** * @notice Creates and sponsors a financing proposal. * @dev Applicant address must not be reserved. * @dev Token address must be allowed/supported by the DAO Bank. * @dev Requested amount must be greater than zero. * @dev Only members of the DAO can sponsor a financing proposal. * @param dao The DAO Address. * @param proposalId The proposal id. * @param applicant The applicant address. * @param token The token to receive the funds. * @param amount The desired amount. * @param details Additional detais about the financing proposal. */ function submitProposal( DaoRegistry dao, bytes32 proposalId, address applicant, address token, uint256 amount, bytes memory data ) external override function processProposal /** * @notice Processing a financing proposal to grant the requested funds. * @dev Only proposals that were not processed are accepted. * @dev Only proposals that were sponsored are accepted. * @dev Only proposals that passed can get processed and have the funds released. * @param dao The DAO Address. * @param proposalId The proposal id. */ function processProposal(DaoRegistry dao, bytes32 proposalId) external override Events No events are emitted from this adapter.","title":"Financing"},{"location":"adapters/Financing/#adapter-description-and-scope","text":"Financing is the process in which an applicant, member or a non-member of the DAO, submits a proposal asking for funds. If the proposal passes, the funds are released to the applicant. The main goal is to allow individuals and/or organizations to request funds to finance their projects, and the members of the DAO have the power to vote and decide which projects should be funded.","title":"Adapter description and scope"},{"location":"adapters/Financing/#adapter-workflow","text":"In order to request funds from the DAO, the applicant must submit a proposal in which one must specify the desired amount and the token address to receive the funds. The applicant address cannot be a reserved address, which means the address is already reserved for the DAO internal usage. Also, the token address must be allowed/supported by the DAO Bank. If these two conditions are not met, the funding proposal is not created.","title":"Adapter workflow"},{"location":"adapters/Financing/#adapter-configuration","text":"Tokens that are provided by the member have to be allowed/supported by the DAO. The member needs to have enough units and/or loot in order to convert it to funds. DAORegistry Access Flags: SUBMIT_PROPOSAL . Bank Extension Access Flags: ADD_TO_BALANCE , SUB_FROM_BALANCE .","title":"Adapter configuration"},{"location":"adapters/Financing/#adapter-state","text":"proposals : all financing proposals handled by each DAO. ProposalDetails : applicant : the proposal applicant address, cannot be a reserved address. amount : the amount requested for funding. token : the token address in which the funding is made to the applicant, needs to be allowed/supported by the DAO Bank.","title":"Adapter state"},{"location":"adapters/Financing/#dependencies-and-interactions-internal-external","text":"BankExtension checks if the provided token is allowed/supported by the Bank. subtracts from Guild balance the requested amount based on the provided token. adds to the applicant account the subtracted amount based on the provided token. DaoRegistry gets Bank extension address. checks if member address is not reserved. submits/sponsors/processes the financing proposal. gets Voting adapter address. Voting gets address that sent the sponsorProposal transaction. starts new voting for the financing proposal. checks the voting results.","title":"Dependencies and interactions (internal / external)"},{"location":"adapters/Financing/#functions-description-and-assumptions-checks","text":"","title":"Functions description and assumptions / checks"},{"location":"adapters/Financing/#receive-external-payable","text":"/** * @notice default fallback function to prevent from sending ether to the contract. */ receive() external payable","title":"receive() external payable"},{"location":"adapters/Financing/#function-submitproposal","text":"/** * @notice Creates and sponsors a financing proposal. * @dev Applicant address must not be reserved. * @dev Token address must be allowed/supported by the DAO Bank. * @dev Requested amount must be greater than zero. * @dev Only members of the DAO can sponsor a financing proposal. * @param dao The DAO Address. * @param proposalId The proposal id. * @param applicant The applicant address. * @param token The token to receive the funds. * @param amount The desired amount. * @param details Additional detais about the financing proposal. */ function submitProposal( DaoRegistry dao, bytes32 proposalId, address applicant, address token, uint256 amount, bytes memory data ) external override","title":"function submitProposal"},{"location":"adapters/Financing/#function-processproposal","text":"/** * @notice Processing a financing proposal to grant the requested funds. * @dev Only proposals that were not processed are accepted. * @dev Only proposals that were sponsored are accepted. * @dev Only proposals that passed can get processed and have the funds released. * @param dao The DAO Address. * @param proposalId The proposal id. */ function processProposal(DaoRegistry dao, bytes32 proposalId) external override","title":"function processProposal"},{"location":"adapters/Financing/#events","text":"No events are emitted from this adapter.","title":"Events"},{"location":"adapters/GuildKick/","text":"Adapter description and scope Guild Kick is the process in which the DAO members decide to kick a member out of the DAO for any given reason. In order to kick out a member of the DAO, the members must submit a proposal which needs to be voted on. If the proposal passes, then the member will be kicked out, and the kicked member will be able to withdraw his funds based on the number of units and/or loot that the member was holding when the kick process was started. The main goal is to give the members the freedom to choose which individuals or organizations should really be part of the DAO. Adapter workflow The guild kick starts with the other members submitting a kick proposal (function submitKickProposal ). The kick proposal indicates which member should be kicked out. A member can not kick himself and only members are allowed to create kick proposals, and proposal ids can not be reused. The kick proposal gets created, opens for voting, and sponsored by the message sender. The adapter tracks all the kicks that have been executed already by each DAO. Once the kick proposal has passed, the other members have to start the actual guild kick process (function processProposal ). The rage kick process is the only alternative for a kicked member to receive his funds. It uses the current guild balance to calculate the fair amount of funds to return to the kicked member. It is important to mention that this step relies on the number of tokens available in the bank, at this moment there is no limit of tokens available in the bank, but soon it will be updated to have a fixed size. The funds are internally transferred from the Guild bank to the kicked member's account, so the member can withdraw the funds later on using the Withdraw Adapter. Adapter configuration Tokens that are provided by the member have to be allowed/supported by the DAO. The member needs to have enough units and/or loot in order to convert it to funds. DAORegistry Access Flags: SUBMIT_PROPOSAL . Bank Extension Access Flags: WITHDRAW , INTERNAL_TRANSFER , SUB_FROM_BALANCE , ADD_TO_BALANCE . Adapter state GuildKickStatus : The kick status ( Not Started , In Progress , Done ). GuildKick : State of the guild kick proposal. memberToKick : The address of the member to kick out of the DAO. status : The kick status. kicks : Keeps track of all the kicks executed per DAO. Dependencies and interactions (internal / external) BankExtension checks the kicked member's balance. subtracts the kicked member's units. adds the burned units to the kicked member's loot account. transfers the funds from the DAO account to the kicked member's account. gets the available tokens. gets the current balance of the guild account. DaoRegistry checks if the message sender is actually a member of the DAO. checks if the kicked member is actually a member of the DAO. process the kick proposal. Voting starts a new voting for the kick proposal. checks the voting results. FairShareHelper to calculate the amount of funds to be returned to the member based on the provided numbers of units and/or loot, taking into account the current balance of the GUILD and kicked member's accounts. Functions description and assumptions / checks receive() external payable /** * @notice default fallback function to prevent from sending ether to the contract. */ receive() external payable function submitProposal /** * @notice Creates a guild kick proposal, opens it for voting, and sponsors it. * @dev A member can not kick himself. * @dev Only members that have units or loot can be kicked out. * @dev Proposal ids can not be reused. * @param dao The dao address. * @param proposalId The guild kick proposal id. * @param memberToKick The member address that should be kicked out of the DAO. * @param data Additional information related to the kick proposal. */ function submitProposal( DaoRegistry dao, bytes32 proposalId, address memberToKick, bytes calldata data ) external override function processProposal If the proposal has passed, sends the fair unit of tokens from the guild bank to the member kicked. Events No events are emitted from this adapter.","title":"GuildKick"},{"location":"adapters/GuildKick/#adapter-description-and-scope","text":"Guild Kick is the process in which the DAO members decide to kick a member out of the DAO for any given reason. In order to kick out a member of the DAO, the members must submit a proposal which needs to be voted on. If the proposal passes, then the member will be kicked out, and the kicked member will be able to withdraw his funds based on the number of units and/or loot that the member was holding when the kick process was started. The main goal is to give the members the freedom to choose which individuals or organizations should really be part of the DAO.","title":"Adapter description and scope"},{"location":"adapters/GuildKick/#adapter-workflow","text":"The guild kick starts with the other members submitting a kick proposal (function submitKickProposal ). The kick proposal indicates which member should be kicked out. A member can not kick himself and only members are allowed to create kick proposals, and proposal ids can not be reused. The kick proposal gets created, opens for voting, and sponsored by the message sender. The adapter tracks all the kicks that have been executed already by each DAO. Once the kick proposal has passed, the other members have to start the actual guild kick process (function processProposal ). The rage kick process is the only alternative for a kicked member to receive his funds. It uses the current guild balance to calculate the fair amount of funds to return to the kicked member. It is important to mention that this step relies on the number of tokens available in the bank, at this moment there is no limit of tokens available in the bank, but soon it will be updated to have a fixed size. The funds are internally transferred from the Guild bank to the kicked member's account, so the member can withdraw the funds later on using the Withdraw Adapter.","title":"Adapter workflow"},{"location":"adapters/GuildKick/#adapter-configuration","text":"Tokens that are provided by the member have to be allowed/supported by the DAO. The member needs to have enough units and/or loot in order to convert it to funds. DAORegistry Access Flags: SUBMIT_PROPOSAL . Bank Extension Access Flags: WITHDRAW , INTERNAL_TRANSFER , SUB_FROM_BALANCE , ADD_TO_BALANCE .","title":"Adapter configuration"},{"location":"adapters/GuildKick/#adapter-state","text":"GuildKickStatus : The kick status ( Not Started , In Progress , Done ). GuildKick : State of the guild kick proposal. memberToKick : The address of the member to kick out of the DAO. status : The kick status. kicks : Keeps track of all the kicks executed per DAO.","title":"Adapter state"},{"location":"adapters/GuildKick/#dependencies-and-interactions-internal-external","text":"BankExtension checks the kicked member's balance. subtracts the kicked member's units. adds the burned units to the kicked member's loot account. transfers the funds from the DAO account to the kicked member's account. gets the available tokens. gets the current balance of the guild account. DaoRegistry checks if the message sender is actually a member of the DAO. checks if the kicked member is actually a member of the DAO. process the kick proposal. Voting starts a new voting for the kick proposal. checks the voting results. FairShareHelper to calculate the amount of funds to be returned to the member based on the provided numbers of units and/or loot, taking into account the current balance of the GUILD and kicked member's accounts.","title":"Dependencies and interactions (internal / external)"},{"location":"adapters/GuildKick/#functions-description-and-assumptions-checks","text":"","title":"Functions description and assumptions / checks"},{"location":"adapters/GuildKick/#receive-external-payable","text":"/** * @notice default fallback function to prevent from sending ether to the contract. */ receive() external payable","title":"receive() external payable"},{"location":"adapters/GuildKick/#function-submitproposal","text":"/** * @notice Creates a guild kick proposal, opens it for voting, and sponsors it. * @dev A member can not kick himself. * @dev Only members that have units or loot can be kicked out. * @dev Proposal ids can not be reused. * @param dao The dao address. * @param proposalId The guild kick proposal id. * @param memberToKick The member address that should be kicked out of the DAO. * @param data Additional information related to the kick proposal. */ function submitProposal( DaoRegistry dao, bytes32 proposalId, address memberToKick, bytes calldata data ) external override","title":"function submitProposal"},{"location":"adapters/GuildKick/#function-processproposal","text":"If the proposal has passed, sends the fair unit of tokens from the guild bank to the member kicked.","title":"function processProposal"},{"location":"adapters/GuildKick/#events","text":"No events are emitted from this adapter.","title":"Events"},{"location":"adapters/HowToCreate/","text":"How to create an Adapter Introduction Defining the Interface Pick the right Adapter type Identifying the Modifiers Map out the proper Access Flags Set up the DAO custom configurations Be mindful of the storage costs Conventions & Implementation Testing the new Adapter Adding documentation Introduction Adapters are well defined, tested and extensible smart contracts that are created with a unique purpose. One Adapter is responsible for performing one or a set of tasks in a given context. With this approach we can develop adapters targeting specific use-cases, and update the DAO configurations to use these new adapters. When a new adapter is created, one needs to submit a Managing proposal to add the new adapter to the DAO. Once the proposal passes, the new adapter is added and becomes available for use. Each adapter needs to be configured with the Access Flags in order to access the Core Contracts , and/or Extensions . Otherwise the Adapter will not able to interact with the DAO. Defining the Interface The adapter must implement one or more of the available interfaces at contracts/adapters/interfaces . If none of these interfaces match the use-case of your adapter, feel free to suggest a new interface. Pick the right Adapter type There are two main types of adapters that serve different purposes: Proposal : writes/reads to/from the DAO state based on a proposal, and the proposal needs to pass, otherwise the DAO state changes are not applied, e.g: GuildKick.sol . Example of a Proposal Adapter ```solidity /* * @notice default fallback function to prevent from sending ether to the contract. / receive() external payable { revert(\"fallback revert\"); } /* * @notice Explain what the function does in addition to the proposal submission. * @dev Describe any required states/checks/parameters that are necessary to execute the function. * @param dao The DAO address. * @param proposalId The proposal id that is managed by the client. * @param param1 Description of the parameter 1. * @param param2 Description of the parameter 2. * @param paramN Description of the parameter n. / function submitProposal( DaoRegistry dao, bytes32 proposalId, type1 param1, type2 param2, typeN paramN ) external override { // If the submission needs to be restricted by DAO members/advisors // it is a good practice to use the helper function from the IVoting interface. // Mainly because if you have an offchain voting Adapter enabled, the sender address may vary. IVoting votingContract = IVoting(dao.getAdapterAddress(VOTING)); address submittedBy = votingContract.getSenderAddress(dao, address(this), data, msg.sender); // Add any required checks here before starting the proposal submission process. required(pre - condition, \"error message\"); // Starts the submissiosn _submitXProposal(dao, proposalId, param1, param2, paramN); } /* * @notice Explain what the submission function does, what kind of checks/validations are performed. Sometimes you may want to sponsor the proposal * right away in the same transaction, so you can do that at the end of the submission process, by calling the dao.sponsorProposal. * @dev Describe any additional checks that the function performs, e.g: only members are allowed, etc. * @param dao The dao address. * @param proposalId The guild kick proposal id. * @param param1 Description of the parameter 1. * @param param2 Description of the parameter 2. * @param paramN Description of the parameter n. / function _submitProposal( DaoRegistry dao, bytes32 proposalId, type1 param1, type2 param2, typeN paramN ) internal onlyMember2(dao, submittedBy) { // onlyMember2 in this case we are restricting the access to members/advisors only // Make sure you create the proposal in the DAO. // The DAO already checks if the proposal id is not a duplicate. dao.submitProposal(proposalId); // Perfom any additional checks or logic you may need. // If you want to sponsor the proposal right away, you need to start the voting process. IVoting votingContract = IVoting(dao.getAdapterAddress(VOTING)); votingContract.startNewVotingForProposal(dao, proposalId, data); // Finally sponsor the x proposal. // The DAO already checks if the proposal exists and is being sent by a member/advisor. dao.sponsorProposal(proposalId, submittedBy); // If you do want to start the voting and sponsor the proposal in the same transaction, // just include these 2 last calls into a new function that must be triggered in another transaction. } /* * @notice Explain what happens during the processProposal execution. * @dev Describe additional validations that are performed in the function. * @param dao The dao address. * @param proposalId The guild kick proposal id. / function processProposal(DaoRegistry dao, bytes32 proposalId) external override { // Update the DAO state to ensure the proposal is processed // The DAO already checks if the proposal id exists, or was already processed, dao.processProposal(proposalId); // Checks if the proposal has passed, otherwise it should not be processed. IVoting votingContract = IVoting(dao.getAdapterAddress(VOTING)); require( votingContract.voteResult(dao, proposalId) == IVoting.VotingState.PASS, \"proposal did not pass\" ); // Here you can update any Adapter state that you may need ... } ``` Generic : writes/reads to/from the DAO state without a proposal, e.g: Withdraw.sol . Example of a Generic Adapter ```solidity /* * @notice default fallback function to prevent from sending ether to the contract. / receive() external payable { revert(\"fallback revert\"); } /* * @notice Explain what the function does, if it changes the DAO state or just reads, etc. * @dev Describe any additional requirements/checks/configurations. * @param dao The DAO address. * @param param1 The description of the parameter 1. / function myFunction(DaoRegistry dao, type1 param1) external { // Add any checks / validation you may need require(pre - condition, \"error message\"); // Instantiate any Extension that you may want to use, e.g: BankExtension bank = BankExtension(dao.getExtensionAddress(BANK)); // Using the extension uint256 balance = bank.balanceOf(account, token); // Executing a transaction that changes the Extension state. bank.functionToCall(param1); // Emit an event if needed. emit MyEvent(address(dao), param1); } ``` Identifying the Modifiers We have adapters that are accessible only to members and/or advisors of the DAO (e.g: Ragequit.sol ), and adapters that are open to any individual or organization, e.g: Financing.sol . While creating the adapter try to identify which sort of users you want to grant access to. Remember that the adapters are the only way we have to alter the DAO state, so be careful with the access modifiers you use. We already have some of them implemented, take a look at the docs/guards , and feel free to suggest new ones if needed. In addition to that, every external function in the adapter must contain the modifier reentrancyGuard(dao) to prevent the reentrancy attack. Map out the proper Access Flags Another important point is to map out which sort of permissions your adapter needs in order to write/read data to/from the DAO. If your adapter requires an Extension , you will also need to provide the correct Access Flags to access that extension. Checkout which permission each flag grants: Flag Helper . Set up the DAO custom configurations Some adapters might need customized/additional configurations to make decisions on the fly. These configurations can and should be set per DAO. In order to do that you need to identify what sort of parameters that you want to keep customizable and set them up through the Configuration Adapter . Be mindful of the storage costs The key advantage of the adapters is to make them very small and suitable to a very specific use-case. With that in mind we try to not use the storage that much. We prefer efficient and cheap adapters that can be easily deployable and maintainable. The less state it maintains and operations it executes, the better. Conventions & Implementation Function names (public) For Adapter that is a Proposal type submitProposal processProposal Function names (private) _myFunction Revert as early as possible Your adapter should not accept any funds. So it is a good practice to always revert the receive call. ```solidity /* * @notice default fallback function to prevent from sending ether to the contract. / receive() external payable { revert(\"fallback revert\"); } ``` Make sure you add the correct require checks Usually the adapter needs to perform some verifications before executing the calls that may change the DAO state. Double check if the DAORegistry functions that your adapter uses already implement some checks, so you do not need to repeat them in the adapter. Update the DAOConstants If you are creating an adapter that does not have the keccak256 id declared in the DAOConstants make sure you add it there. Testing the new Adapter In order to verify if the new adapter works properly, one needs to implement the basic test suite, so we can ensure it is actually doing what it was supposed to do. There are several examples of tests that you can check to start building your own. Take a look at the tests/adapters . The general idea is to create one test suite per adapter/contract. And try to cover all the happy paths first, and then add more complex test cases after that. You need to declare the new adapter contract to ContractUtil.js , so it can be accessed in the deploy/test environment. In order to speed up the test suites we usually don't create one DAO per test function, but we create the DAO during the suite initialization, and only reset the chain after each test function using the chain snapshot feature. For instance: describe(\"Adapter - AdapterName\", () => { /** * Using the utility function `deployDefaultDao` * to create the DAO before all tests are * executed. * Once the DAO is created you can access the * adapters, extensions, factories, testContracts * and votingHelpers contracts. Use the test global scope * to store them and access it later in the test functions. */ before(\"deploy dao\", async () => { const { dao, adapters, extensions, factories, testContracts, votingHelpers, } = await deployDefaultDao({ owner }); this.dao = dao; this.adapters = adapters; this.extensions = extensions; }); /** * Before each test funtion we take a chain snapshot, which * contains the fresh DAO configurations with zero * modifications. */ beforeEach(async () => { this.snapshotId = await takeChainSnapshot(); }); /** * After the test function is executed we revert to the * latest chain snapshot took when the DAO was fresh * installed. * With this approach we save time in the DAO creation, * and the test suite runs 10x faster. */ afterEach(async () => { await revertChainSnapshot(this.snapshotId); }); /** * Add a descriptive name to your test function that * covers the use case that you are testing. */ it(\"should be possible to set a single configuration parameter\", async () => { // Access the global scope to read the contracts you may need. const dao = this.dao; const configuration = this.adapters.configuration; const voting = this.adapters.voting; // Use openzeppelin test-env to assert results, events,and failures, e.g: expect(value1.toString()).equal(\"1\"); expectEvent(tx.receipt, \"EventName\", { eventArg1: value1, eventArg2: toBN(\"2\"), //value 2 }); await expectRevert( // Calling the contract function that returns promise configuration.submitProposal(dao.address, \"0x1\", [key], [], [], { from: owner, gasPrice: toBN(\"0\"), }), \"must be an equal number of config keys and values\" ); }); }); Another important step in the test phase is to configure the adapter permissions during the DAO creation in the DAOFactory.js . If the adapter that you are using is not part of the default set of adapters, you need to import it from ContractUtil.js , and deploy it, then you can configure the Adapter access flags after the adapter is created in the test suite, but before the DAO is finalized. When the DAO is finalized it means that the DAO initialization has been completed, so any state changes must be done though a proposal, instead of doing it through the deployment phase. Here is a simple example of an adapter configurated after its creation, but before the DAO is finalized: describe(\"Adapter - AdapterName2\", () => { it(\"should be possible to...\", async () => { // Creating the new DAO without finalizing it // So you can add new adapters without going through // a proposal process. const { dao, factories, extensions } = await deployDefaultDao({ owner: owner, finalize: false, }); // Creating your adapter const myAdapter2Contract = await MyAdapter2Contract.new(); // Once the dao is created, use the daoFactory contract // to add the new adapter to the DAO with the correct // ACL using the `addAdapters` function: await factories.daoFactory.addAdapters( dao.address, // When you are creating an adapter that access the DAO // state, you need to provide the `entryDAO` ACL // from DeploymentUtil.entryDao [entryDao(\"myAdapter2\", myAdapter2Contract, { THE_ACL_FLAG_1: true // the name of the ACL flag, that needs to be enabled. // for more info checkout: // https://github.com/openlawteam/tribute-contracts/blob/master/docs/core/DaoRegistry.md#access-flags })], { from: owner } ); // If your adapter needs to access a DAO Extension, // you can set up your adapter to access the extension // using the `daoFactory.configureExtension` function: await factories.daoFactory.configureExtension( dao.address, myAdapter2Contract.address, [ entryExecutor(myAdapter2Contract, { THE_ACL_FLAG_X: true, // the name of the ACL flag, that needs to be enabled. // Checkout the extension documentation for more info: // https://github.com/openlawteam/tribute-contracts/tree/master/docs/extensions }), ], { from: owner } ); // After the adapter was configured to access the DAO, // and/or an Extension, you can finalize the DAO creation. await dao.finalizeDao({ from: owner }); // Start your test here ... }); }); Adding documentation Each adapter must provide its own documentation describing what is the use-case it solves, what are the functions and interactions it contains. There is a template that you can use to create the docs for your new adapter, check out the Template.md . Done If you have followed all the steps above and created a well tested, documented Adapter, please submit a Pull Request so we can review it and provide additional feedback. Thank you!","title":"How to create an Adapter"},{"location":"adapters/HowToCreate/#how-to-create-an-adapter","text":"Introduction Defining the Interface Pick the right Adapter type Identifying the Modifiers Map out the proper Access Flags Set up the DAO custom configurations Be mindful of the storage costs Conventions & Implementation Testing the new Adapter Adding documentation","title":"How to create an Adapter"},{"location":"adapters/HowToCreate/#introduction","text":"Adapters are well defined, tested and extensible smart contracts that are created with a unique purpose. One Adapter is responsible for performing one or a set of tasks in a given context. With this approach we can develop adapters targeting specific use-cases, and update the DAO configurations to use these new adapters. When a new adapter is created, one needs to submit a Managing proposal to add the new adapter to the DAO. Once the proposal passes, the new adapter is added and becomes available for use. Each adapter needs to be configured with the Access Flags in order to access the Core Contracts , and/or Extensions . Otherwise the Adapter will not able to interact with the DAO.","title":"Introduction"},{"location":"adapters/HowToCreate/#defining-the-interface","text":"The adapter must implement one or more of the available interfaces at contracts/adapters/interfaces . If none of these interfaces match the use-case of your adapter, feel free to suggest a new interface.","title":"Defining the Interface"},{"location":"adapters/HowToCreate/#pick-the-right-adapter-type","text":"There are two main types of adapters that serve different purposes: Proposal : writes/reads to/from the DAO state based on a proposal, and the proposal needs to pass, otherwise the DAO state changes are not applied, e.g: GuildKick.sol . Example of a Proposal Adapter ```solidity /* * @notice default fallback function to prevent from sending ether to the contract. / receive() external payable { revert(\"fallback revert\"); } /* * @notice Explain what the function does in addition to the proposal submission. * @dev Describe any required states/checks/parameters that are necessary to execute the function. * @param dao The DAO address. * @param proposalId The proposal id that is managed by the client. * @param param1 Description of the parameter 1. * @param param2 Description of the parameter 2. * @param paramN Description of the parameter n. / function submitProposal( DaoRegistry dao, bytes32 proposalId, type1 param1, type2 param2, typeN paramN ) external override { // If the submission needs to be restricted by DAO members/advisors // it is a good practice to use the helper function from the IVoting interface. // Mainly because if you have an offchain voting Adapter enabled, the sender address may vary. IVoting votingContract = IVoting(dao.getAdapterAddress(VOTING)); address submittedBy = votingContract.getSenderAddress(dao, address(this), data, msg.sender); // Add any required checks here before starting the proposal submission process. required(pre - condition, \"error message\"); // Starts the submissiosn _submitXProposal(dao, proposalId, param1, param2, paramN); } /* * @notice Explain what the submission function does, what kind of checks/validations are performed. Sometimes you may want to sponsor the proposal * right away in the same transaction, so you can do that at the end of the submission process, by calling the dao.sponsorProposal. * @dev Describe any additional checks that the function performs, e.g: only members are allowed, etc. * @param dao The dao address. * @param proposalId The guild kick proposal id. * @param param1 Description of the parameter 1. * @param param2 Description of the parameter 2. * @param paramN Description of the parameter n. / function _submitProposal( DaoRegistry dao, bytes32 proposalId, type1 param1, type2 param2, typeN paramN ) internal onlyMember2(dao, submittedBy) { // onlyMember2 in this case we are restricting the access to members/advisors only // Make sure you create the proposal in the DAO. // The DAO already checks if the proposal id is not a duplicate. dao.submitProposal(proposalId); // Perfom any additional checks or logic you may need. // If you want to sponsor the proposal right away, you need to start the voting process. IVoting votingContract = IVoting(dao.getAdapterAddress(VOTING)); votingContract.startNewVotingForProposal(dao, proposalId, data); // Finally sponsor the x proposal. // The DAO already checks if the proposal exists and is being sent by a member/advisor. dao.sponsorProposal(proposalId, submittedBy); // If you do want to start the voting and sponsor the proposal in the same transaction, // just include these 2 last calls into a new function that must be triggered in another transaction. } /* * @notice Explain what happens during the processProposal execution. * @dev Describe additional validations that are performed in the function. * @param dao The dao address. * @param proposalId The guild kick proposal id. / function processProposal(DaoRegistry dao, bytes32 proposalId) external override { // Update the DAO state to ensure the proposal is processed // The DAO already checks if the proposal id exists, or was already processed, dao.processProposal(proposalId); // Checks if the proposal has passed, otherwise it should not be processed. IVoting votingContract = IVoting(dao.getAdapterAddress(VOTING)); require( votingContract.voteResult(dao, proposalId) == IVoting.VotingState.PASS, \"proposal did not pass\" ); // Here you can update any Adapter state that you may need ... } ``` Generic : writes/reads to/from the DAO state without a proposal, e.g: Withdraw.sol . Example of a Generic Adapter ```solidity /* * @notice default fallback function to prevent from sending ether to the contract. / receive() external payable { revert(\"fallback revert\"); } /* * @notice Explain what the function does, if it changes the DAO state or just reads, etc. * @dev Describe any additional requirements/checks/configurations. * @param dao The DAO address. * @param param1 The description of the parameter 1. / function myFunction(DaoRegistry dao, type1 param1) external { // Add any checks / validation you may need require(pre - condition, \"error message\"); // Instantiate any Extension that you may want to use, e.g: BankExtension bank = BankExtension(dao.getExtensionAddress(BANK)); // Using the extension uint256 balance = bank.balanceOf(account, token); // Executing a transaction that changes the Extension state. bank.functionToCall(param1); // Emit an event if needed. emit MyEvent(address(dao), param1); } ```","title":"Pick the right Adapter type"},{"location":"adapters/HowToCreate/#identifying-the-modifiers","text":"We have adapters that are accessible only to members and/or advisors of the DAO (e.g: Ragequit.sol ), and adapters that are open to any individual or organization, e.g: Financing.sol . While creating the adapter try to identify which sort of users you want to grant access to. Remember that the adapters are the only way we have to alter the DAO state, so be careful with the access modifiers you use. We already have some of them implemented, take a look at the docs/guards , and feel free to suggest new ones if needed. In addition to that, every external function in the adapter must contain the modifier reentrancyGuard(dao) to prevent the reentrancy attack.","title":"Identifying the Modifiers"},{"location":"adapters/HowToCreate/#map-out-the-proper-access-flags","text":"Another important point is to map out which sort of permissions your adapter needs in order to write/read data to/from the DAO. If your adapter requires an Extension , you will also need to provide the correct Access Flags to access that extension. Checkout which permission each flag grants: Flag Helper .","title":"Map out the proper Access Flags"},{"location":"adapters/HowToCreate/#set-up-the-dao-custom-configurations","text":"Some adapters might need customized/additional configurations to make decisions on the fly. These configurations can and should be set per DAO. In order to do that you need to identify what sort of parameters that you want to keep customizable and set them up through the Configuration Adapter .","title":"Set up the DAO custom configurations"},{"location":"adapters/HowToCreate/#be-mindful-of-the-storage-costs","text":"The key advantage of the adapters is to make them very small and suitable to a very specific use-case. With that in mind we try to not use the storage that much. We prefer efficient and cheap adapters that can be easily deployable and maintainable. The less state it maintains and operations it executes, the better.","title":"Be mindful of the storage costs"},{"location":"adapters/HowToCreate/#conventions-implementation","text":"Function names (public) For Adapter that is a Proposal type submitProposal processProposal Function names (private) _myFunction Revert as early as possible Your adapter should not accept any funds. So it is a good practice to always revert the receive call. ```solidity /* * @notice default fallback function to prevent from sending ether to the contract. / receive() external payable { revert(\"fallback revert\"); } ``` Make sure you add the correct require checks Usually the adapter needs to perform some verifications before executing the calls that may change the DAO state. Double check if the DAORegistry functions that your adapter uses already implement some checks, so you do not need to repeat them in the adapter. Update the DAOConstants If you are creating an adapter that does not have the keccak256 id declared in the DAOConstants make sure you add it there.","title":"Conventions &amp; Implementation"},{"location":"adapters/HowToCreate/#testing-the-new-adapter","text":"In order to verify if the new adapter works properly, one needs to implement the basic test suite, so we can ensure it is actually doing what it was supposed to do. There are several examples of tests that you can check to start building your own. Take a look at the tests/adapters . The general idea is to create one test suite per adapter/contract. And try to cover all the happy paths first, and then add more complex test cases after that. You need to declare the new adapter contract to ContractUtil.js , so it can be accessed in the deploy/test environment. In order to speed up the test suites we usually don't create one DAO per test function, but we create the DAO during the suite initialization, and only reset the chain after each test function using the chain snapshot feature. For instance: describe(\"Adapter - AdapterName\", () => { /** * Using the utility function `deployDefaultDao` * to create the DAO before all tests are * executed. * Once the DAO is created you can access the * adapters, extensions, factories, testContracts * and votingHelpers contracts. Use the test global scope * to store them and access it later in the test functions. */ before(\"deploy dao\", async () => { const { dao, adapters, extensions, factories, testContracts, votingHelpers, } = await deployDefaultDao({ owner }); this.dao = dao; this.adapters = adapters; this.extensions = extensions; }); /** * Before each test funtion we take a chain snapshot, which * contains the fresh DAO configurations with zero * modifications. */ beforeEach(async () => { this.snapshotId = await takeChainSnapshot(); }); /** * After the test function is executed we revert to the * latest chain snapshot took when the DAO was fresh * installed. * With this approach we save time in the DAO creation, * and the test suite runs 10x faster. */ afterEach(async () => { await revertChainSnapshot(this.snapshotId); }); /** * Add a descriptive name to your test function that * covers the use case that you are testing. */ it(\"should be possible to set a single configuration parameter\", async () => { // Access the global scope to read the contracts you may need. const dao = this.dao; const configuration = this.adapters.configuration; const voting = this.adapters.voting; // Use openzeppelin test-env to assert results, events,and failures, e.g: expect(value1.toString()).equal(\"1\"); expectEvent(tx.receipt, \"EventName\", { eventArg1: value1, eventArg2: toBN(\"2\"), //value 2 }); await expectRevert( // Calling the contract function that returns promise configuration.submitProposal(dao.address, \"0x1\", [key], [], [], { from: owner, gasPrice: toBN(\"0\"), }), \"must be an equal number of config keys and values\" ); }); }); Another important step in the test phase is to configure the adapter permissions during the DAO creation in the DAOFactory.js . If the adapter that you are using is not part of the default set of adapters, you need to import it from ContractUtil.js , and deploy it, then you can configure the Adapter access flags after the adapter is created in the test suite, but before the DAO is finalized. When the DAO is finalized it means that the DAO initialization has been completed, so any state changes must be done though a proposal, instead of doing it through the deployment phase. Here is a simple example of an adapter configurated after its creation, but before the DAO is finalized: describe(\"Adapter - AdapterName2\", () => { it(\"should be possible to...\", async () => { // Creating the new DAO without finalizing it // So you can add new adapters without going through // a proposal process. const { dao, factories, extensions } = await deployDefaultDao({ owner: owner, finalize: false, }); // Creating your adapter const myAdapter2Contract = await MyAdapter2Contract.new(); // Once the dao is created, use the daoFactory contract // to add the new adapter to the DAO with the correct // ACL using the `addAdapters` function: await factories.daoFactory.addAdapters( dao.address, // When you are creating an adapter that access the DAO // state, you need to provide the `entryDAO` ACL // from DeploymentUtil.entryDao [entryDao(\"myAdapter2\", myAdapter2Contract, { THE_ACL_FLAG_1: true // the name of the ACL flag, that needs to be enabled. // for more info checkout: // https://github.com/openlawteam/tribute-contracts/blob/master/docs/core/DaoRegistry.md#access-flags })], { from: owner } ); // If your adapter needs to access a DAO Extension, // you can set up your adapter to access the extension // using the `daoFactory.configureExtension` function: await factories.daoFactory.configureExtension( dao.address, myAdapter2Contract.address, [ entryExecutor(myAdapter2Contract, { THE_ACL_FLAG_X: true, // the name of the ACL flag, that needs to be enabled. // Checkout the extension documentation for more info: // https://github.com/openlawteam/tribute-contracts/tree/master/docs/extensions }), ], { from: owner } ); // After the adapter was configured to access the DAO, // and/or an Extension, you can finalize the DAO creation. await dao.finalizeDao({ from: owner }); // Start your test here ... }); });","title":"Testing the new Adapter"},{"location":"adapters/HowToCreate/#adding-documentation","text":"Each adapter must provide its own documentation describing what is the use-case it solves, what are the functions and interactions it contains. There is a template that you can use to create the docs for your new adapter, check out the Template.md .","title":"Adding documentation"},{"location":"adapters/HowToCreate/#done","text":"If you have followed all the steps above and created a well tested, documented Adapter, please submit a Pull Request so we can review it and provide additional feedback. Thank you!","title":"Done"},{"location":"adapters/Managing/","text":"Adapter description and scope The Managing adapter handles the proposal creation, sponsorship and processing of a new adapter including its initial configuration, and permissions. An adapter can be added, removed or replaced in the DAO registry. In order to remove an adapter one must pass the address 0x0 with the adapter id that needs to be removed. In order to add a new adapter one most provide the adapter id, address and access flags. The address of the new adapter can not be a reserved address, and the id must be a known id as defined in the DaoConstants.sol . The replace adapter operation removes the adapter from the registry based on the adapter id parameter, and also adds a new adapter using the same id but with a new address. Adapter workflow Submit a proposal and check: if caller is an active member if keys and values have equal length if adapter address is valid if the access flags don't overflow if adapter address is not reserved If all the requirements pass, then the proposal is subitted to registry and the adapter stores the proposal data. To sponsor a proposal, you need to be an active member, and once sponsored the voting process starts. Once the voting period ends, only a member can process the proposal. The proposal is processed only if: the caller is an active member the has not been processed already the proposal has been sponsored the voting has passed Adapter configuration DAORegistry Access Flags: SUBMIT_PROPOSAL , REPLACE_ADAPTER . Adapter state proposals : All the proposals handled by the adapter per DAO. ProposalDetails : adapterId : The id of the adapter to add, remove or replace. adapterAddress : The address of the new adapter contract. keys : The configuration keys for the adapter. values : The values to set for the adapter configuration. flags : The ACL for the new adapter. Dependencies and interactions (internal / external) DaoRegistry Submits/sponsors/processes a proposal. Checks if applicant and/or adapter address are not reserved. Executes the replaceAdapter call to update the registry. Voting Gets the address that sent the sponsorProposal transaction. Starts a new voting for the kick proposal. Checks the voting results. Functions description and assumptions / checks function submitProposal /** * @notice Creates a proposal to replace, remove or add an adapter. * @dev If the adapterAddress is equal to 0x0, the adapterId is removed from the registry if available. * @dev If the adapterAddress is a reserved address, it reverts. * @dev keys and value must have the same length. * @dev proposalId can not be reused. * @param dao The dao address. * @param proposalId The guild kick proposal id. * @param adapterId The adapter id to replace, remove or add. * @param adapterAddress The adapter address to add or replace. Use 0x0 if you want to remove the adapter. * @param keys The configuration keys for the adapter. * @param values The values to set for the adapter configuration. * @param _flags The ACL for the new adapter, up to 2**128-1. */ function submitProposal( DaoRegistry dao, bytes32 proposalId, bytes32 adapterId, address adapterAddress, bytes32[] calldata keys, uint256[] calldata values, uint256 _flags ) external override onlyMember(dao) function sponsorProposal /** * @notice Sponsor a proposal if the proposal id exists. * @dev Only members are allowed to sponsor proposals. * @param dao The dao address. * @param proposalId The guild kick proposal id. * @param data Additional data that can be used for offchain voting validation. */ function sponsorProposal( DaoRegistry dao, bytes32 proposalId, bytes calldata data ) external override onlyMember(dao) function processProposal /** * @notice Processes a proposal that was sponsored. * @dev Only members can process a proposal. * @dev Only if the voting pass the proposal is processed. * @dev Reverts when the adapter address is already in use and it is an adapter addition. * @param dao The dao address. * @param proposalId The guild kick proposal id. */ function processProposal(DaoRegistry dao, bytes32 proposalId) external override onlyMember(dao) Events AdapterRemoved : when an adapter is removed from the regitry. Event emitted by the DAO Registry. AdapterAdded : when a new adapter is added to the registry. Event emitted by the DAO Registry. ConfigurationUpdated : when a new configuration is stored in the registry. Event emitted by the DAO Registry.","title":"Managing"},{"location":"adapters/Managing/#adapter-description-and-scope","text":"The Managing adapter handles the proposal creation, sponsorship and processing of a new adapter including its initial configuration, and permissions. An adapter can be added, removed or replaced in the DAO registry. In order to remove an adapter one must pass the address 0x0 with the adapter id that needs to be removed. In order to add a new adapter one most provide the adapter id, address and access flags. The address of the new adapter can not be a reserved address, and the id must be a known id as defined in the DaoConstants.sol . The replace adapter operation removes the adapter from the registry based on the adapter id parameter, and also adds a new adapter using the same id but with a new address.","title":"Adapter description and scope"},{"location":"adapters/Managing/#adapter-workflow","text":"Submit a proposal and check: if caller is an active member if keys and values have equal length if adapter address is valid if the access flags don't overflow if adapter address is not reserved If all the requirements pass, then the proposal is subitted to registry and the adapter stores the proposal data. To sponsor a proposal, you need to be an active member, and once sponsored the voting process starts. Once the voting period ends, only a member can process the proposal. The proposal is processed only if: the caller is an active member the has not been processed already the proposal has been sponsored the voting has passed","title":"Adapter workflow"},{"location":"adapters/Managing/#adapter-configuration","text":"DAORegistry Access Flags: SUBMIT_PROPOSAL , REPLACE_ADAPTER .","title":"Adapter configuration"},{"location":"adapters/Managing/#adapter-state","text":"proposals : All the proposals handled by the adapter per DAO. ProposalDetails : adapterId : The id of the adapter to add, remove or replace. adapterAddress : The address of the new adapter contract. keys : The configuration keys for the adapter. values : The values to set for the adapter configuration. flags : The ACL for the new adapter.","title":"Adapter state"},{"location":"adapters/Managing/#dependencies-and-interactions-internal-external","text":"DaoRegistry Submits/sponsors/processes a proposal. Checks if applicant and/or adapter address are not reserved. Executes the replaceAdapter call to update the registry. Voting Gets the address that sent the sponsorProposal transaction. Starts a new voting for the kick proposal. Checks the voting results.","title":"Dependencies and interactions (internal / external)"},{"location":"adapters/Managing/#functions-description-and-assumptions-checks","text":"","title":"Functions description and assumptions / checks"},{"location":"adapters/Managing/#function-submitproposal","text":"/** * @notice Creates a proposal to replace, remove or add an adapter. * @dev If the adapterAddress is equal to 0x0, the adapterId is removed from the registry if available. * @dev If the adapterAddress is a reserved address, it reverts. * @dev keys and value must have the same length. * @dev proposalId can not be reused. * @param dao The dao address. * @param proposalId The guild kick proposal id. * @param adapterId The adapter id to replace, remove or add. * @param adapterAddress The adapter address to add or replace. Use 0x0 if you want to remove the adapter. * @param keys The configuration keys for the adapter. * @param values The values to set for the adapter configuration. * @param _flags The ACL for the new adapter, up to 2**128-1. */ function submitProposal( DaoRegistry dao, bytes32 proposalId, bytes32 adapterId, address adapterAddress, bytes32[] calldata keys, uint256[] calldata values, uint256 _flags ) external override onlyMember(dao)","title":"function submitProposal"},{"location":"adapters/Managing/#function-sponsorproposal","text":"/** * @notice Sponsor a proposal if the proposal id exists. * @dev Only members are allowed to sponsor proposals. * @param dao The dao address. * @param proposalId The guild kick proposal id. * @param data Additional data that can be used for offchain voting validation. */ function sponsorProposal( DaoRegistry dao, bytes32 proposalId, bytes calldata data ) external override onlyMember(dao)","title":"function sponsorProposal"},{"location":"adapters/Managing/#function-processproposal","text":"/** * @notice Processes a proposal that was sponsored. * @dev Only members can process a proposal. * @dev Only if the voting pass the proposal is processed. * @dev Reverts when the adapter address is already in use and it is an adapter addition. * @param dao The dao address. * @param proposalId The guild kick proposal id. */ function processProposal(DaoRegistry dao, bytes32 proposalId) external override onlyMember(dao)","title":"function processProposal"},{"location":"adapters/Managing/#events","text":"AdapterRemoved : when an adapter is removed from the regitry. Event emitted by the DAO Registry. AdapterAdded : when a new adapter is added to the registry. Event emitted by the DAO Registry. ConfigurationUpdated : when a new configuration is stored in the registry. Event emitted by the DAO Registry.","title":"Events"},{"location":"adapters/OffchainVoting/","text":"Adapter description and scope This adapter manages offchain voting using a merkle tree to commit to a result that can be challenge during the grace period if necessary. There are also two fallback solutions implemented: fallback voting that falls back to simple onchain voting if something is wrong admin force fail proposal to mark a proposal as failed by an admin if necessary. This is present until a more formal verfication of the system is done General concept The idea is to use a merkle tree to commit to a computation (calculate the result) and have a way to challenge a result if anyone sees an issue in the computation. The approach assumes data availability. Each leaf in the merkle tree is a \"step\" in computing the vote result. The last leaf is the result (and the leaf submitted). This works with a modified version of snapshot that uses ERC-712 for hashing / signing proposals and votes Adapter configuration VotingPeriod = keccak256(\"voting.votingPeriod\") How long does a vote occur. GracePeriod = keccak256(\"voting.gracePeriod\") How long does anyeone have to challenge a result if an issue is spotted. FallbackThreshold = keccak256(\"offchainvoting.fallbackThreshold\") What threshold ( in % ) of members need to request a fallback voting for it to kick in. Functions description, assumptions, checks, dependencies, interactions and access control function adminFailProposal(DaoRegistry dao, bytes32 proposalId) Admin function (only owner can call it) to fail a proposal. Used as a failsafe if anything goes wrong since the adapter is still new function submitVoteResult(DaoRegistry dao, bytes32 proposalId, bytes32 resultRoot, VoteResultNode memory result) external Submits a new vote result for a specific dao / proposalId. result is the last step that contains the vote result. resultRoot is the merkle root of the computation merkle tree. If a result has been already published, it checks whether this one has more steps (index is higher) or if the vote is already finished. If the voting period is not done yet but the result cannot be changed anymore (50+% have voted either yes or no), the grace period starts right away function voteResult(DaoRegistry dao, bytes32 proposalId) returns (VotingState state) Returns the status of a vote session. function challengeBadNode(DaoRegistry dao, bytes32 proposalId, VoteResultNode memory nodeCurrent) external Checks and marks a result as bad if a specific node has bad data. The checks are: bad signature invalid choice bad proposalHash vote timestamp is after the current grace period started function _isValidChoice(uint256 choice) internal pure returns (bool) function defining what a valid choice is function challengeBadStep(DaoRegistry dao, bytes32 proposalId, VoteResultNode memory nodePrevious, VoteResultNode memory nodeCurrent) external Checks that the step from a node to another is correct or not let's define a step function S(state, choice) that creates a new state based on a previous one and a choice We check that S(previousState, currentChoice) = currentState If not, we challenge the result function requestFallback(DaoRegistry dao, bytes32 proposalId) external onlyMember(dao) If something is wrong with the vote but it is not possible to challenge it, members can request a fallback function sponsorChallengeProposal(DaoRegistry dao, bytes32 proposalId, address sponsoredBy) If a result has been challenged, it is needed to vote on the faith of the reporter. Should he continue being a member or should he be banned. function processChallengeProposal(DaoRegistry dao, bytes32 proposalId) Process the vote for the faith of a bad reporter","title":"OffchainVoting"},{"location":"adapters/OffchainVoting/#adapter-description-and-scope","text":"This adapter manages offchain voting using a merkle tree to commit to a result that can be challenge during the grace period if necessary. There are also two fallback solutions implemented: fallback voting that falls back to simple onchain voting if something is wrong admin force fail proposal to mark a proposal as failed by an admin if necessary. This is present until a more formal verfication of the system is done","title":"Adapter description and scope"},{"location":"adapters/OffchainVoting/#general-concept","text":"The idea is to use a merkle tree to commit to a computation (calculate the result) and have a way to challenge a result if anyone sees an issue in the computation. The approach assumes data availability. Each leaf in the merkle tree is a \"step\" in computing the vote result. The last leaf is the result (and the leaf submitted). This works with a modified version of snapshot that uses ERC-712 for hashing / signing proposals and votes","title":"General concept"},{"location":"adapters/OffchainVoting/#adapter-configuration","text":"","title":"Adapter configuration"},{"location":"adapters/OffchainVoting/#votingperiod-keccak256votingvotingperiod","text":"How long does a vote occur.","title":"VotingPeriod = keccak256(\"voting.votingPeriod\")"},{"location":"adapters/OffchainVoting/#graceperiod-keccak256votinggraceperiod","text":"How long does anyeone have to challenge a result if an issue is spotted.","title":"GracePeriod = keccak256(\"voting.gracePeriod\")"},{"location":"adapters/OffchainVoting/#fallbackthreshold-keccak256offchainvotingfallbackthreshold","text":"What threshold ( in % ) of members need to request a fallback voting for it to kick in.","title":"FallbackThreshold = keccak256(\"offchainvoting.fallbackThreshold\")"},{"location":"adapters/OffchainVoting/#functions-description-assumptions-checks-dependencies-interactions-and-access-control","text":"","title":"Functions description, assumptions, checks, dependencies, interactions and access control"},{"location":"adapters/OffchainVoting/#function-adminfailproposaldaoregistry-dao-bytes32-proposalid","text":"Admin function (only owner can call it) to fail a proposal. Used as a failsafe if anything goes wrong since the adapter is still new","title":"function adminFailProposal(DaoRegistry dao, bytes32 proposalId)"},{"location":"adapters/OffchainVoting/#function-submitvoteresultdaoregistry-dao-bytes32-proposalid-bytes32-resultroot-voteresultnode-memory-result-external","text":"Submits a new vote result for a specific dao / proposalId. result is the last step that contains the vote result. resultRoot is the merkle root of the computation merkle tree. If a result has been already published, it checks whether this one has more steps (index is higher) or if the vote is already finished. If the voting period is not done yet but the result cannot be changed anymore (50+% have voted either yes or no), the grace period starts right away","title":"function submitVoteResult(DaoRegistry dao, bytes32 proposalId, bytes32 resultRoot, VoteResultNode memory result) external"},{"location":"adapters/OffchainVoting/#function-voteresultdaoregistry-dao-bytes32-proposalid-returns-votingstate-state","text":"Returns the status of a vote session.","title":"function voteResult(DaoRegistry dao, bytes32 proposalId) returns (VotingState state)"},{"location":"adapters/OffchainVoting/#function-challengebadnodedaoregistry-dao-bytes32-proposalid-voteresultnode-memory-nodecurrent-external","text":"Checks and marks a result as bad if a specific node has bad data. The checks are: bad signature invalid choice bad proposalHash vote timestamp is after the current grace period started","title":"function challengeBadNode(DaoRegistry dao, bytes32 proposalId, VoteResultNode memory nodeCurrent) external"},{"location":"adapters/OffchainVoting/#function-_isvalidchoiceuint256-choice-internal-pure-returns-bool","text":"function defining what a valid choice is","title":"function _isValidChoice(uint256 choice) internal pure returns (bool)"},{"location":"adapters/OffchainVoting/#function-challengebadstepdaoregistry-dao-bytes32-proposalid-voteresultnode-memory-nodeprevious-voteresultnode-memory-nodecurrent-external","text":"Checks that the step from a node to another is correct or not let's define a step function S(state, choice) that creates a new state based on a previous one and a choice We check that S(previousState, currentChoice) = currentState If not, we challenge the result","title":"function challengeBadStep(DaoRegistry dao, bytes32 proposalId, VoteResultNode memory nodePrevious, VoteResultNode memory nodeCurrent) external"},{"location":"adapters/OffchainVoting/#function-requestfallbackdaoregistry-dao-bytes32-proposalid-external-onlymemberdao","text":"If something is wrong with the vote but it is not possible to challenge it, members can request a fallback","title":"function requestFallback(DaoRegistry dao, bytes32 proposalId) external onlyMember(dao)"},{"location":"adapters/OffchainVoting/#function-sponsorchallengeproposaldaoregistry-dao-bytes32-proposalid-address-sponsoredby","text":"If a result has been challenged, it is needed to vote on the faith of the reporter. Should he continue being a member or should he be banned.","title":"function sponsorChallengeProposal(DaoRegistry dao, bytes32 proposalId, address sponsoredBy)"},{"location":"adapters/OffchainVoting/#function-processchallengeproposaldaoregistry-dao-bytes32-proposalid","text":"Process the vote for the faith of a bad reporter","title":"function processChallengeProposal(DaoRegistry dao, bytes32 proposalId)"},{"location":"adapters/Onboarding/","text":"Adapter description and scope The Onboarding adapter allows potential and existing DAO members to contribute Ether or ERC-20 tokens to the DAO in exchange for a fixed amount of internal tokens (e.g., UNITS or LOOT tokens already registered with the DAO Bank) based on the amount of assets contributed. If the proposal passes, the internal tokens are minted to the applicant (which effectively makes the applicant a member of the DAO if not already one) and the tokens provided as tribute are transferred to the Bank extension. You can mint any internal tokens but it is usually to mint either UNITS or LOOT tokens. The onboarding process supports raw Ether and ERC-20 tokens as tribute. The ERC-20 token must be allowed/supported by the Bank. Adapter workflow An onboarding proposal is made by a member first submitting a proposal specifying (1) the applicant who wishes to join the DAO (or increase his stake in the DAO), (2) the type of internal tokens the applicant desires (e.g., member UNITS), and (3) the amount of Ether or ERC-20 tokens that will transfer to the DAO in exchange for those internal tokens. The applicant and actual owner of the ERC-20 tokens can be separate accounts (e.g., the token owner is providing tribute on behalf of the applicant). The internal token type requested must be already registered with the DAO Bank and will usually be pre-defined UNITS or LOOT tokens in the DAO. The proposal submission does not actually transfer the Ether or ERC-20 tokens from its owner. That occurs only after the proposal passes and is processed. The proposal is also sponsored in the same transaction when it is submitted. When a DAO member sponsors the proposal, the voting period begins allowing members to vote for or against the proposal. Only a member can sponsor the proposal. After the voting period is done along with its subsequent grace period, the proposal can be processed. Any account can process a failed proposal. However, only the original proposer (owner of the assets being transferred to the DAO) can process a passed proposal. Prior to processing a passed proposal involving ERC-20 tribute tokens, the owner of those tokens must first separately approve the Onboarding adapter as spender of the tokens provided as tribute. Upon processing, if the vote has passed, the internal tokens are minted to the applicant (which effectively makes the applicant a member of the DAO if not already one). The amount of Ether or ERC-20 tokens provided as tribute are added to the Guild balance and transferred from the token owner to the Bank extension. Upon processing, if the vote has failed (i.e., more NO votes then YES votes or a tie), no further action is taken (the owner of the Ether or ERC-20 tokens still retains ownership of the assets). Adapter configuration Each configuration is done based on the token address that needs to be minted. DAORegistry Access Flags: SUBMIT_PROPOSAL , UPDATE_DELEGATE_KEY , NEW_MEMBER . Bank Extension Access Flags: ADD_TO_BALANCE . Adapter state onboarding.chunkSize How many tokens need to be minted per chunk bought. onboarding.unitsPerChunk How many units (tokens from tokenAddr) are being minted per chunk. onboarding.tokenAddr In which currency (tokenAddr) should the onboarding take place. onboarding.maximumChunks How many chunks can someone buy max. This helps force decentralization of token holders. Adapter state Onboarding keeps track of every proposal that goes through it as well as the number of tokens that have been minted so far. ProposalDetails For each proposal created through the adapter, we keep track of the following information: id The proposalId (provided offchain). unitsToMint Which token needs to be minted if the proposal passes. amount The amount sent by the proposer. unitsRequested The amount of internal tokens that needs to be minted to the applicant if the proposal passes. token What currency has been used in the onboarding process. We keep this information even though it is part of the configuration to handle the case where the configuration changes while a proposal has been created but not processed yet. applicant The applicant address. proposals mapping The proposals are organized by DAO address and then by proposal id. units Accounting to see the amount of a particular internal token that has been minted for a particular applicant. This is then checked against the maxChunks configuration to determine if the onboarding proposal is allowed or not. Functions description and assumptions / checks function configKey(address tokenAddrToMint, bytes32 key) returns (bytes32) This is the function to build the config key for a particular tokenAddrToMint. It's a pure function. function configureDao(DaoRegistry dao, address unitsToMint, uint256 chunkSize, uint256 unitsPerChunk, uint256 maximumChunks, address tokenAddr) This function configures the adapter for a particular DAO. The modifier is adapterOnly which means that only if the sender is either a registered adapter of the DAO or if it is in creation mode can it be called. The function checks that chunkSize, unitsPerChunks and maximumChunks cannot be 0. tokenAddr is being whitelisted in the bank extension as an ERC-20 token unitsToMint is being whitelisted in the bank extension as an internal token dependency The adapter also needs a Bank extension. So confgureDao will fail if no bank extension is found. function submitProposal(DaoRegistry dao, bytes32 proposalId, address payable applicant, address tokenToMint, uint256 tokenAmount, bytes memory data) Submits and sponsors the proposal. Only members can call this function. This function uses _submitMembershipProposal to create the proposal. This function uses _sponsorProposal to sponsor the proposal. function _sponsorProposal(DaoRegistry dao, bytes32 proposalId, bytes memory data) This internal function starts a vote on the proposal to onboard a new member. dao.sponsorProposal(proposalId, sponsoredBy, address(votingContract)) checks already that the proposal has not been sponsored yet voting.startNewVotingForProposal(dao, proposalId, data) starts the vote process function processProposal(DaoRegistry dao, bytes32 proposalId) Once the vote on a proposal is finished, it is time to process it. Anybody can call this function. The function checks that there is a vote in progress for this proposalId and that it has not been processed yet. If the vote is a success ( PASS ), then we process it by minting the internal tokens and moving the tokens from the adapter to the bank extension. If the vote is a tie ( TIE ) or failed ( NOT_PASS ), then the funds are returned to the proposer. Otherwise, the state is invalid and the transaction is reverted (if the vote does not exist or if it is in progress). function _submitMembershipProposal(DaoRegistry dao, bytes32 proposalId, address tokenToMint, address payable applicant, uint256 value, address token) This function marks the proposalId as submitted in the DAO and saves the information in the internal adapter state. Events No events are emitted from this adapter.","title":"Onboarding"},{"location":"adapters/Onboarding/#adapter-description-and-scope","text":"The Onboarding adapter allows potential and existing DAO members to contribute Ether or ERC-20 tokens to the DAO in exchange for a fixed amount of internal tokens (e.g., UNITS or LOOT tokens already registered with the DAO Bank) based on the amount of assets contributed. If the proposal passes, the internal tokens are minted to the applicant (which effectively makes the applicant a member of the DAO if not already one) and the tokens provided as tribute are transferred to the Bank extension. You can mint any internal tokens but it is usually to mint either UNITS or LOOT tokens. The onboarding process supports raw Ether and ERC-20 tokens as tribute. The ERC-20 token must be allowed/supported by the Bank.","title":"Adapter description and scope"},{"location":"adapters/Onboarding/#adapter-workflow","text":"An onboarding proposal is made by a member first submitting a proposal specifying (1) the applicant who wishes to join the DAO (or increase his stake in the DAO), (2) the type of internal tokens the applicant desires (e.g., member UNITS), and (3) the amount of Ether or ERC-20 tokens that will transfer to the DAO in exchange for those internal tokens. The applicant and actual owner of the ERC-20 tokens can be separate accounts (e.g., the token owner is providing tribute on behalf of the applicant). The internal token type requested must be already registered with the DAO Bank and will usually be pre-defined UNITS or LOOT tokens in the DAO. The proposal submission does not actually transfer the Ether or ERC-20 tokens from its owner. That occurs only after the proposal passes and is processed. The proposal is also sponsored in the same transaction when it is submitted. When a DAO member sponsors the proposal, the voting period begins allowing members to vote for or against the proposal. Only a member can sponsor the proposal. After the voting period is done along with its subsequent grace period, the proposal can be processed. Any account can process a failed proposal. However, only the original proposer (owner of the assets being transferred to the DAO) can process a passed proposal. Prior to processing a passed proposal involving ERC-20 tribute tokens, the owner of those tokens must first separately approve the Onboarding adapter as spender of the tokens provided as tribute. Upon processing, if the vote has passed, the internal tokens are minted to the applicant (which effectively makes the applicant a member of the DAO if not already one). The amount of Ether or ERC-20 tokens provided as tribute are added to the Guild balance and transferred from the token owner to the Bank extension. Upon processing, if the vote has failed (i.e., more NO votes then YES votes or a tie), no further action is taken (the owner of the Ether or ERC-20 tokens still retains ownership of the assets).","title":"Adapter workflow"},{"location":"adapters/Onboarding/#adapter-configuration","text":"Each configuration is done based on the token address that needs to be minted. DAORegistry Access Flags: SUBMIT_PROPOSAL , UPDATE_DELEGATE_KEY , NEW_MEMBER . Bank Extension Access Flags: ADD_TO_BALANCE .","title":"Adapter configuration"},{"location":"adapters/Onboarding/#adapter-state","text":"","title":"Adapter state"},{"location":"adapters/Onboarding/#onboardingchunksize","text":"How many tokens need to be minted per chunk bought.","title":"onboarding.chunkSize"},{"location":"adapters/Onboarding/#onboardingunitsperchunk","text":"How many units (tokens from tokenAddr) are being minted per chunk.","title":"onboarding.unitsPerChunk"},{"location":"adapters/Onboarding/#onboardingtokenaddr","text":"In which currency (tokenAddr) should the onboarding take place.","title":"onboarding.tokenAddr"},{"location":"adapters/Onboarding/#onboardingmaximumchunks","text":"How many chunks can someone buy max. This helps force decentralization of token holders.","title":"onboarding.maximumChunks"},{"location":"adapters/Onboarding/#adapter-state_1","text":"Onboarding keeps track of every proposal that goes through it as well as the number of tokens that have been minted so far.","title":"Adapter state"},{"location":"adapters/Onboarding/#proposaldetails","text":"For each proposal created through the adapter, we keep track of the following information:","title":"ProposalDetails"},{"location":"adapters/Onboarding/#id","text":"The proposalId (provided offchain).","title":"id"},{"location":"adapters/Onboarding/#unitstomint","text":"Which token needs to be minted if the proposal passes.","title":"unitsToMint"},{"location":"adapters/Onboarding/#amount","text":"The amount sent by the proposer.","title":"amount"},{"location":"adapters/Onboarding/#unitsrequested","text":"The amount of internal tokens that needs to be minted to the applicant if the proposal passes.","title":"unitsRequested"},{"location":"adapters/Onboarding/#token","text":"What currency has been used in the onboarding process. We keep this information even though it is part of the configuration to handle the case where the configuration changes while a proposal has been created but not processed yet.","title":"token"},{"location":"adapters/Onboarding/#applicant","text":"The applicant address.","title":"applicant"},{"location":"adapters/Onboarding/#proposals-mapping","text":"The proposals are organized by DAO address and then by proposal id.","title":"proposals mapping"},{"location":"adapters/Onboarding/#units","text":"Accounting to see the amount of a particular internal token that has been minted for a particular applicant. This is then checked against the maxChunks configuration to determine if the onboarding proposal is allowed or not.","title":"units"},{"location":"adapters/Onboarding/#functions-description-and-assumptions-checks","text":"","title":"Functions description and assumptions / checks"},{"location":"adapters/Onboarding/#function-configkeyaddress-tokenaddrtomint-bytes32-key-returns-bytes32","text":"This is the function to build the config key for a particular tokenAddrToMint. It's a pure function.","title":"function configKey(address tokenAddrToMint, bytes32 key) returns (bytes32)"},{"location":"adapters/Onboarding/#function-configuredaodaoregistry-dao-address-unitstomint-uint256-chunksize-uint256-unitsperchunk-uint256-maximumchunks-address-tokenaddr","text":"This function configures the adapter for a particular DAO. The modifier is adapterOnly which means that only if the sender is either a registered adapter of the DAO or if it is in creation mode can it be called. The function checks that chunkSize, unitsPerChunks and maximumChunks cannot be 0. tokenAddr is being whitelisted in the bank extension as an ERC-20 token unitsToMint is being whitelisted in the bank extension as an internal token","title":"function configureDao(DaoRegistry dao, address unitsToMint, uint256 chunkSize, uint256 unitsPerChunk, uint256 maximumChunks, address tokenAddr)"},{"location":"adapters/Onboarding/#dependency","text":"The adapter also needs a Bank extension. So confgureDao will fail if no bank extension is found.","title":"dependency"},{"location":"adapters/Onboarding/#function-submitproposaldaoregistry-dao-bytes32-proposalid-address-payable-applicant-address-tokentomint-uint256-tokenamount-bytes-memory-data","text":"Submits and sponsors the proposal. Only members can call this function. This function uses _submitMembershipProposal to create the proposal. This function uses _sponsorProposal to sponsor the proposal.","title":"function submitProposal(DaoRegistry dao, bytes32 proposalId, address payable applicant, address tokenToMint, uint256 tokenAmount, bytes memory data)"},{"location":"adapters/Onboarding/#function-_sponsorproposaldaoregistry-dao-bytes32-proposalid-bytes-memory-data","text":"This internal function starts a vote on the proposal to onboard a new member. dao.sponsorProposal(proposalId, sponsoredBy, address(votingContract)) checks already that the proposal has not been sponsored yet voting.startNewVotingForProposal(dao, proposalId, data) starts the vote process","title":"function _sponsorProposal(DaoRegistry dao, bytes32 proposalId, bytes memory data)"},{"location":"adapters/Onboarding/#function-processproposaldaoregistry-dao-bytes32-proposalid","text":"Once the vote on a proposal is finished, it is time to process it. Anybody can call this function. The function checks that there is a vote in progress for this proposalId and that it has not been processed yet. If the vote is a success ( PASS ), then we process it by minting the internal tokens and moving the tokens from the adapter to the bank extension. If the vote is a tie ( TIE ) or failed ( NOT_PASS ), then the funds are returned to the proposer. Otherwise, the state is invalid and the transaction is reverted (if the vote does not exist or if it is in progress).","title":"function processProposal(DaoRegistry dao, bytes32 proposalId)"},{"location":"adapters/Onboarding/#function-_submitmembershipproposaldaoregistry-dao-bytes32-proposalid-address-tokentomint-address-payable-applicant-uint256-value-address-token","text":"This function marks the proposalId as submitted in the DAO and saves the information in the internal adapter state.","title":"function _submitMembershipProposal(DaoRegistry dao, bytes32 proposalId, address tokenToMint, address payable applicant, uint256 value, address token)"},{"location":"adapters/Onboarding/#events","text":"No events are emitted from this adapter.","title":"Events"},{"location":"adapters/Ragequit/","text":"Adapter description and scope Ragequit is the process in which a member of the DAO decides to opt out of the DAO for any given reason. This implementation of ragequit adapter does not cover the case in which the member is put in jail before updating the internal balance - as it happens in Moloch V2 to disincentivize the behavior in which members vote Yes on proposals that are essentially bad for the future of the DAO, and right after that they quit with their funds. It also does not check if the member has voted Yes on a proposal that is not processed yet, and does not keep track of the latest proposal that was voted Yes on. The main goal is to give the members the freedom to choose when it is the best time to withdraw their funds without any additional preconditions, except for the fact that they need to have enough units to be converted to funds. Members do not need to convert all their units/loot at once. Adapter workflow In order to opt out of the DAO, the member needs to indicate the amount of units and/or loots that the member has decided to burn (to convert back into a token value). The proportional units and/or loots are burned when the member provides the tokens in which one expects to receive the funds. The funds are deducted from the internal DAO bank balance, and added to the member's internal balance. If the member provides at least one invalid token, e.g: a token that is not supported/allowed by the DAO, the entire ragequit process is canceled/reverted. By default the adapter expects that the token array is sorted in ascending order. This is done to test for duplicates, and each token needs to be smaller than the next one, otherwise the transaction is reverted. In addition to that, if the member provides a long list of tokens that may cause issues due to the block size limit, it is expected that the transaction returns a failure, so it can be retried in another run with a fewer tokens. Once the ragequit process is completed, the funds are deducted from the bank, added to the member's internal balance, and an event called MemberRagequit is emitted. Adapter configuration Tokens that are provided by the member have to be allowed/supported by the DAO. The member/advisor needs to have enough units and/or loot in order to convert it to funds. DAORegistry Access Flags: Bank Extension Access Flags: WITHDRAW , INTERNAL_TRANSFER , SUB_FROM_BALANCE , ADD_TO_BALANCE . Adapter state There is no state tracking for this adapter. Dependencies and interactions (internal / external) BankExtension checks the member's balance. subtracts the member's balance. transfers the funds from the DAO account to the member's account taking into consideration the provided tokens. checks if the provided token is supported/allowed by the DAO. DaoRegistry checks if the message sender is actually a member or an advisor of the DAO. FairShareHelper calculates the amount of funds to be returned to the member based on the provided numbers of units and/or loot, and current balance of the Guild. Functions description and assumptions / checks receive() external payable /** * @notice default fallback function to prevent from sending ether to the contract. */ receive() external payable function ragequit /** * @notice Allows a member or advisor of the DAO to opt out by burning the proportional amount of units/loot of the member. * @notice Anyone is allowed to call this function, but only members and advisors that have units are able to execute the entire ragequit process. * @notice The array of token needs to be sorted in ascending order before executing this call, otherwise the transaction will fail. * @dev The sum of unitsToBurn and lootToBurn have to be greater than zero. * @dev The member becomes an inactive member of the DAO once all the units/loot are burned. * @dev If the member provides an invalid/not allowed token, the entire processed is reverted. * @dev If no tokens are informed, the transaction is reverted. * @param dao The dao address that the member is part of. * @param unitsToBurn The amount of units of the member that must be converted into funds. * @param lootToBurn The amount of loot of the member that must be converted into funds. * @param tokens The array of tokens that the funds should be sent to. */ function ragequit( DaoRegistry dao, uint256 unitsToBurn, uint256 lootToBurn, address[] memory tokens ) external function _prepareRagequit /** * @notice Subtracts from the internal member's account the proportional units and/or loot. * @param memberAddr The member address that wants to burn the units and/or loot. * @param unitsToBurn The amount of units of the member that must be converted into funds. * @param lootToBurn The amount of loot of the member that must be converted into funds. * @param tokens The array of tokens that the funds should be sent to. * @param bank The bank extension. */ function _prepareRagequit( address memberAddr, uint256 unitsToBurn, uint256 lootToBurn, address[] calldata tokens, BankExtension bank ) internal function _burnUnits /** * @notice Subtracts from the bank's account the proportional units and/or loot, * @notice and transfers the funds to the member's internal account based on the provided tokens. * @param memberAddr The member address that wants to burn the units and/or loot. * @param unitsToBurn The amount of units of the member that must be converted into funds. * @param lootToBurn The amount of loot of the member that must be converted into funds. * @param initialTotalUnitsAndLoot The sum of units and loot before internal transfers. * @param tokens The array of tokens that the funds should be sent to. * @param bank The bank extension. */ function _burnUnits( address memberAddr, uint256 unitsToBurn, uint256 lootToBurn, uint256 initialTotalUnitsAndLoot, address[] memory tokens, BankExtension bank ) internal Events event MemberRagequit /** * @notice Event emitted when a member of the DAO executes a ragequit * with all or parts of the member's units/loot. */ event MemberRagequit( address memberAddr, uint256 burnedUnits, uint256 burnedLoot, uint256 initialTotalUnitsAndLoot)","title":"Ragequit"},{"location":"adapters/Ragequit/#adapter-description-and-scope","text":"Ragequit is the process in which a member of the DAO decides to opt out of the DAO for any given reason. This implementation of ragequit adapter does not cover the case in which the member is put in jail before updating the internal balance - as it happens in Moloch V2 to disincentivize the behavior in which members vote Yes on proposals that are essentially bad for the future of the DAO, and right after that they quit with their funds. It also does not check if the member has voted Yes on a proposal that is not processed yet, and does not keep track of the latest proposal that was voted Yes on. The main goal is to give the members the freedom to choose when it is the best time to withdraw their funds without any additional preconditions, except for the fact that they need to have enough units to be converted to funds. Members do not need to convert all their units/loot at once.","title":"Adapter description and scope"},{"location":"adapters/Ragequit/#adapter-workflow","text":"In order to opt out of the DAO, the member needs to indicate the amount of units and/or loots that the member has decided to burn (to convert back into a token value). The proportional units and/or loots are burned when the member provides the tokens in which one expects to receive the funds. The funds are deducted from the internal DAO bank balance, and added to the member's internal balance. If the member provides at least one invalid token, e.g: a token that is not supported/allowed by the DAO, the entire ragequit process is canceled/reverted. By default the adapter expects that the token array is sorted in ascending order. This is done to test for duplicates, and each token needs to be smaller than the next one, otherwise the transaction is reverted. In addition to that, if the member provides a long list of tokens that may cause issues due to the block size limit, it is expected that the transaction returns a failure, so it can be retried in another run with a fewer tokens. Once the ragequit process is completed, the funds are deducted from the bank, added to the member's internal balance, and an event called MemberRagequit is emitted.","title":"Adapter workflow"},{"location":"adapters/Ragequit/#adapter-configuration","text":"Tokens that are provided by the member have to be allowed/supported by the DAO. The member/advisor needs to have enough units and/or loot in order to convert it to funds. DAORegistry Access Flags: Bank Extension Access Flags: WITHDRAW , INTERNAL_TRANSFER , SUB_FROM_BALANCE , ADD_TO_BALANCE .","title":"Adapter configuration"},{"location":"adapters/Ragequit/#adapter-state","text":"There is no state tracking for this adapter.","title":"Adapter state"},{"location":"adapters/Ragequit/#dependencies-and-interactions-internal-external","text":"BankExtension checks the member's balance. subtracts the member's balance. transfers the funds from the DAO account to the member's account taking into consideration the provided tokens. checks if the provided token is supported/allowed by the DAO. DaoRegistry checks if the message sender is actually a member or an advisor of the DAO. FairShareHelper calculates the amount of funds to be returned to the member based on the provided numbers of units and/or loot, and current balance of the Guild.","title":"Dependencies and interactions (internal / external)"},{"location":"adapters/Ragequit/#functions-description-and-assumptions-checks","text":"","title":"Functions description and assumptions / checks"},{"location":"adapters/Ragequit/#receive-external-payable","text":"/** * @notice default fallback function to prevent from sending ether to the contract. */ receive() external payable","title":"receive() external payable"},{"location":"adapters/Ragequit/#function-ragequit","text":"/** * @notice Allows a member or advisor of the DAO to opt out by burning the proportional amount of units/loot of the member. * @notice Anyone is allowed to call this function, but only members and advisors that have units are able to execute the entire ragequit process. * @notice The array of token needs to be sorted in ascending order before executing this call, otherwise the transaction will fail. * @dev The sum of unitsToBurn and lootToBurn have to be greater than zero. * @dev The member becomes an inactive member of the DAO once all the units/loot are burned. * @dev If the member provides an invalid/not allowed token, the entire processed is reverted. * @dev If no tokens are informed, the transaction is reverted. * @param dao The dao address that the member is part of. * @param unitsToBurn The amount of units of the member that must be converted into funds. * @param lootToBurn The amount of loot of the member that must be converted into funds. * @param tokens The array of tokens that the funds should be sent to. */ function ragequit( DaoRegistry dao, uint256 unitsToBurn, uint256 lootToBurn, address[] memory tokens ) external","title":"function ragequit"},{"location":"adapters/Ragequit/#function-_prepareragequit","text":"/** * @notice Subtracts from the internal member's account the proportional units and/or loot. * @param memberAddr The member address that wants to burn the units and/or loot. * @param unitsToBurn The amount of units of the member that must be converted into funds. * @param lootToBurn The amount of loot of the member that must be converted into funds. * @param tokens The array of tokens that the funds should be sent to. * @param bank The bank extension. */ function _prepareRagequit( address memberAddr, uint256 unitsToBurn, uint256 lootToBurn, address[] calldata tokens, BankExtension bank ) internal","title":"function _prepareRagequit"},{"location":"adapters/Ragequit/#function-_burnunits","text":"/** * @notice Subtracts from the bank's account the proportional units and/or loot, * @notice and transfers the funds to the member's internal account based on the provided tokens. * @param memberAddr The member address that wants to burn the units and/or loot. * @param unitsToBurn The amount of units of the member that must be converted into funds. * @param lootToBurn The amount of loot of the member that must be converted into funds. * @param initialTotalUnitsAndLoot The sum of units and loot before internal transfers. * @param tokens The array of tokens that the funds should be sent to. * @param bank The bank extension. */ function _burnUnits( address memberAddr, uint256 unitsToBurn, uint256 lootToBurn, uint256 initialTotalUnitsAndLoot, address[] memory tokens, BankExtension bank ) internal","title":"function _burnUnits"},{"location":"adapters/Ragequit/#events","text":"","title":"Events"},{"location":"adapters/Ragequit/#event-memberragequit","text":"/** * @notice Event emitted when a member of the DAO executes a ragequit * with all or parts of the member's units/loot. */ event MemberRagequit( address memberAddr, uint256 burnedUnits, uint256 burnedLoot, uint256 initialTotalUnitsAndLoot)","title":"event MemberRagequit"},{"location":"adapters/Template/","text":"Adapter description and scope This is a template for the documentation of an Adapter. Here you can provide a brief description of the adapter and what is the use-case covered by the implementation. It is also good to add the goal of the Adapter and what value it brings to the DAO. Adapter workflow An overview of the entire process executed by Adapter functions, the main interactions and routines covered/executed. Adapter configuration Specify which additional configurations are required to make this adapter work. For instance: needs access to the DAO members, needs access to the DAO Bank, relies on Adapter X, Y and Extension Z. DAORegistry Access Flags: SUBMIT_PROPOSAL , .... Bank Extension Access Flags: WITHDRAW , INTERNAL_TRANSFER , .... Adapter state Describe each variable public and private of the adapter and what is the purpose of that variable. Dependencies and interactions (internal / external) Add the information about all the interactions that are triggered by this DAO, which contracts it depends on, and which functions it calls. Functions description and assumptions / checks Describe the public and private functions signatures with proper documentation and clearly explain what each function does. Specify what are expected the arguments and pre-conditions to execute the functions. Also, provide what is the expected outcome. Examples: receive() external payable function submitKickProposal /** * @notice Creates a guild kick proposal, opens it for voting, and sponsors it. * @dev A member can not kick himself. * @dev Only one kick per DAO can be executed at time. * @dev Only members that have units can be kicked out. * @dev Proposal ids can not be reused. * @param dao The dao address. * @param proposalId The guild kick proposal id. * @param memberToKick The member address that should be kicked out of the DAO. * @param data Additional information related to the kick proposal. */ function submitKickProposal( DaoRegistry dao, bytes32 proposalId, address memberToKick, bytes calldata data ) external override onlyMember(dao) Events List all the events that are emitted by the function in this Adapter implementation.","title":"Template"},{"location":"adapters/Template/#adapter-description-and-scope","text":"This is a template for the documentation of an Adapter. Here you can provide a brief description of the adapter and what is the use-case covered by the implementation. It is also good to add the goal of the Adapter and what value it brings to the DAO.","title":"Adapter description and scope"},{"location":"adapters/Template/#adapter-workflow","text":"An overview of the entire process executed by Adapter functions, the main interactions and routines covered/executed.","title":"Adapter workflow"},{"location":"adapters/Template/#adapter-configuration","text":"Specify which additional configurations are required to make this adapter work. For instance: needs access to the DAO members, needs access to the DAO Bank, relies on Adapter X, Y and Extension Z. DAORegistry Access Flags: SUBMIT_PROPOSAL , .... Bank Extension Access Flags: WITHDRAW , INTERNAL_TRANSFER , ....","title":"Adapter configuration"},{"location":"adapters/Template/#adapter-state","text":"Describe each variable public and private of the adapter and what is the purpose of that variable.","title":"Adapter state"},{"location":"adapters/Template/#dependencies-and-interactions-internal-external","text":"Add the information about all the interactions that are triggered by this DAO, which contracts it depends on, and which functions it calls.","title":"Dependencies and interactions (internal / external)"},{"location":"adapters/Template/#functions-description-and-assumptions-checks","text":"Describe the public and private functions signatures with proper documentation and clearly explain what each function does. Specify what are expected the arguments and pre-conditions to execute the functions. Also, provide what is the expected outcome. Examples:","title":"Functions description and assumptions / checks"},{"location":"adapters/Template/#receive-external-payable","text":"","title":"receive() external payable"},{"location":"adapters/Template/#function-submitkickproposal","text":"/** * @notice Creates a guild kick proposal, opens it for voting, and sponsors it. * @dev A member can not kick himself. * @dev Only one kick per DAO can be executed at time. * @dev Only members that have units can be kicked out. * @dev Proposal ids can not be reused. * @param dao The dao address. * @param proposalId The guild kick proposal id. * @param memberToKick The member address that should be kicked out of the DAO. * @param data Additional information related to the kick proposal. */ function submitKickProposal( DaoRegistry dao, bytes32 proposalId, address memberToKick, bytes calldata data ) external override onlyMember(dao)","title":"function submitKickProposal"},{"location":"adapters/Template/#events","text":"List all the events that are emitted by the function in this Adapter implementation.","title":"Events"},{"location":"adapters/Tribute/","text":"Adapter description and scope The Tribute adapter allows potential and existing DAO members to contribute any amount of ERC-20 tokens to the DAO in exchange for any amount of DAO internal tokens (e.g., UNITS or LOOT tokens already registered with the DAO Bank). If the proposal passes, the requested internal tokens are minted to the applicant (which effectively makes the applicant a member of the DAO if not already one) and the tokens provided as tribute are transferred to the Bank extension. The Tribute adapter is similar to the Onboarding adapter in that both allow for joining the DAO (or increasing a stake in the DAO) through the exchange of contributed assets for DAO internal tokens. However, there are key differences: The Onboarding adapter allows both Ether and ERC-20 tokens to be contributed. The Tribute adapter accepts only ERC-20 tokens. The Onboarding adapter mints a fixed amount of internal tokens to the applicant based on the amount of assets contributed. In other words, an onboarding proposal does not specify the amount of internal tokens requested. That is calculated from the DAO's configurations and the amount of assets contributed. The Tribute adapter has more open-ended proposal parameters. The proposer can request any amount of internal tokens to be minted in exchange for any amount of any ERC-20 tokens contributed. The worthiness of that transfer proposal for the DAO is left to the vote of its members. Adapter workflow A tribute is made by a member first submitting a proposal specifying (1) the applicant who wishes to join the DAO (or increase his stake in the DAO), (2) the amount and type of internal tokens the applicant desires (e.g., member UNITS), and (3) the amount, type, and owner of ERC-20 tokens that will transfer to the DAO in exchange for those internal tokens. The applicant and actual owner of the ERC-20 tokens can be separate accounts (e.g., the token owner is providing tribute on behalf of the applicant). The internal token type requested must be already registered with the DAO Bank and will usually be pre-defined UNITS or LOOT tokens in the DAO. The proposal submission does not actually transfer the ERC-20 tokens from its owner. That occurs only after the proposal passes and is processed. The proposal is also sponsored in the same transaction when it is submitted. When a DAO member sponsors the proposal, the voting period begins allowing members to vote for or against the proposal. Only a member can sponsor the proposal. After the voting period is done along with its subsequent grace period, the proposal can be processed. Any account can process the proposal. However, prior to processing a passed proposal, the owner of the ERC-20 tribute tokens must first separately approve the Tribute adapter as spender of the tokens provided as tribute. Upon processing, if the vote has passed, the requested internal tokens are minted to the applicant (which effectively makes the applicant a member of the DAO if not already one). The tribute token is registered with the DAO Bank (if not already registered), and the amount of tribute tokens are added to the Guild balance and transferred from the token owner to the Bank extension. Upon processing, if the vote has failed (i.e., more NO votes then YES votes or a tie), no further action is taken (the owner of the ERC-20 tribute tokens still retains ownership of the tokens). Adapter configuration A DAO Bank extension must exist and be configured with proper access for this adapter. The DAO internal tokens to be minted to the applicant must be registered with the DAO Bank. DAORegistry Access Flags: SUBMIT_PROPOSAL , NEW_MEMBER . Bank Extension Access Flags: ADD_TO_BALANCE , REGISTER_NEW_TOKEN . Adapter state proposals : All tribute proposals handled by each DAO. ProposalDetails : id : The proposal id. applicant : The applicant address (who will receive the DAO internal tokens and become a member; this address may be different than the actual owner of the ERC-20 tokens being provided as tribute). tokenToMint : The address of the DAO internal token to be minted to the applicant. requestAmount : The amount requested of DAO internal tokens. token : The address of the ERC-20 tokens that will be transferred to the DAO in exchange for DAO internal tokens. tributeAmount : The amount of tribute tokens. tributeTokenOwner : The owner of the ERC-20 tokens being provided as tribute. Dependencies and interactions (internal / external) BankExtension Registers DAO internal token to be minted to the applicant in adapter configuration. Checks if tribute token (ERC-20) is registered with the DAO Bank. Registers tribute token for a passed proposal (if not already registered). Adds to the Guild balance the amount of tribute tokens. Checks if the DAO internal token to be minted to the applicant is registered with the DAO Bank. Adds to the applicant balance the amount of requested DAO internal tokens. DaoRegistry Gets Bank extension address. Checks if applicant address is not reserved. Gets Voting adapter address. Submits/sponsors/processes the tribute proposal. Checks if proposal flag is SPONSORED , PROCESSED . Creates a new member entry (if applicant is not already a member). Voting Gets address that sent the sponsorProposal transaction. Starts new voting for the tribute proposal. Checks the voting results. Functions description and assumptions / checks receive() external payable /** * @notice default fallback function to prevent from sending ether to the contract. */ receive() external payable function configureDao /** * @notice Configures the adapter for a particular DAO. * @notice Registers the DAO internal token with the DAO Bank. * @dev Only adapters registered to the DAO can execute the function call (or if the DAO is in creation mode). * @dev A DAO Bank extension must exist and be configured with proper access for this adapter. * @param dao The DAO address. * @param tokenAddrToMint The internal token address to be registered with the DAO Bank. */ function configureDao(DaoRegistry dao, address tokenAddrToMint) external onlyAdapter(dao) function submitProposal /** * @notice Creates and sponsors a tribute proposal to start the voting process. * @dev Applicant address must not be reserved. * @dev Only members of the DAO can sponsor a tribute proposal. * @param dao The DAO address. * @param proposalId The proposal id (managed by the client). * @param applicant The applicant address (who will receive the DAO internal tokens and become a member). * @param tokenToMint The address of the DAO internal token to be minted to the applicant. * @param requestAmount The amount requested of DAO internal tokens. * @param tokenAddr The address of the ERC-20 tokens that will be transferred to the DAO in exchange for DAO internal tokens. * @param tributeAmount The amount of tribute tokens. * @param tributeTokenOwner The owner of the ERC-20 tokens being provided as tribute. * @param data Additional information related to the tribute proposal. */ function submitProposal( DaoRegistry dao, bytes32 proposalId, address applicant, address tokenToMint, uint256 requestAmount, address tokenAddr, uint256 tributeAmount, address tributeTokenOwner, bytes memory data ) external reentrancyGuard(dao) function processProposal /** * @notice Processes a tribute proposal to handle minting and exchange of DAO internal tokens for tribute tokens (passed vote). * @dev Proposal id must exist. * @dev Only proposals that have not already been processed are accepted. * @dev Only sponsored proposals with completed voting are accepted. * @dev The owner of the ERC-20 tokens provided as tribute must first separately `approve` the adapter as spender of those tokens (so the tokens can be transferred for a passed vote). * @dev ERC-20 tribute tokens must be registered with the DAO Bank (a passed proposal will check and register the token if needed). * @param dao The DAO address. * @param proposalId The proposal id. */ function processProposal(DaoRegistry dao, bytes32 proposalId) external reentrancyGuard(dao) Events No events are emitted from this adapter.","title":"Tribute"},{"location":"adapters/Tribute/#adapter-description-and-scope","text":"The Tribute adapter allows potential and existing DAO members to contribute any amount of ERC-20 tokens to the DAO in exchange for any amount of DAO internal tokens (e.g., UNITS or LOOT tokens already registered with the DAO Bank). If the proposal passes, the requested internal tokens are minted to the applicant (which effectively makes the applicant a member of the DAO if not already one) and the tokens provided as tribute are transferred to the Bank extension. The Tribute adapter is similar to the Onboarding adapter in that both allow for joining the DAO (or increasing a stake in the DAO) through the exchange of contributed assets for DAO internal tokens. However, there are key differences: The Onboarding adapter allows both Ether and ERC-20 tokens to be contributed. The Tribute adapter accepts only ERC-20 tokens. The Onboarding adapter mints a fixed amount of internal tokens to the applicant based on the amount of assets contributed. In other words, an onboarding proposal does not specify the amount of internal tokens requested. That is calculated from the DAO's configurations and the amount of assets contributed. The Tribute adapter has more open-ended proposal parameters. The proposer can request any amount of internal tokens to be minted in exchange for any amount of any ERC-20 tokens contributed. The worthiness of that transfer proposal for the DAO is left to the vote of its members.","title":"Adapter description and scope"},{"location":"adapters/Tribute/#adapter-workflow","text":"A tribute is made by a member first submitting a proposal specifying (1) the applicant who wishes to join the DAO (or increase his stake in the DAO), (2) the amount and type of internal tokens the applicant desires (e.g., member UNITS), and (3) the amount, type, and owner of ERC-20 tokens that will transfer to the DAO in exchange for those internal tokens. The applicant and actual owner of the ERC-20 tokens can be separate accounts (e.g., the token owner is providing tribute on behalf of the applicant). The internal token type requested must be already registered with the DAO Bank and will usually be pre-defined UNITS or LOOT tokens in the DAO. The proposal submission does not actually transfer the ERC-20 tokens from its owner. That occurs only after the proposal passes and is processed. The proposal is also sponsored in the same transaction when it is submitted. When a DAO member sponsors the proposal, the voting period begins allowing members to vote for or against the proposal. Only a member can sponsor the proposal. After the voting period is done along with its subsequent grace period, the proposal can be processed. Any account can process the proposal. However, prior to processing a passed proposal, the owner of the ERC-20 tribute tokens must first separately approve the Tribute adapter as spender of the tokens provided as tribute. Upon processing, if the vote has passed, the requested internal tokens are minted to the applicant (which effectively makes the applicant a member of the DAO if not already one). The tribute token is registered with the DAO Bank (if not already registered), and the amount of tribute tokens are added to the Guild balance and transferred from the token owner to the Bank extension. Upon processing, if the vote has failed (i.e., more NO votes then YES votes or a tie), no further action is taken (the owner of the ERC-20 tribute tokens still retains ownership of the tokens).","title":"Adapter workflow"},{"location":"adapters/Tribute/#adapter-configuration","text":"A DAO Bank extension must exist and be configured with proper access for this adapter. The DAO internal tokens to be minted to the applicant must be registered with the DAO Bank. DAORegistry Access Flags: SUBMIT_PROPOSAL , NEW_MEMBER . Bank Extension Access Flags: ADD_TO_BALANCE , REGISTER_NEW_TOKEN .","title":"Adapter configuration"},{"location":"adapters/Tribute/#adapter-state","text":"proposals : All tribute proposals handled by each DAO. ProposalDetails : id : The proposal id. applicant : The applicant address (who will receive the DAO internal tokens and become a member; this address may be different than the actual owner of the ERC-20 tokens being provided as tribute). tokenToMint : The address of the DAO internal token to be minted to the applicant. requestAmount : The amount requested of DAO internal tokens. token : The address of the ERC-20 tokens that will be transferred to the DAO in exchange for DAO internal tokens. tributeAmount : The amount of tribute tokens. tributeTokenOwner : The owner of the ERC-20 tokens being provided as tribute.","title":"Adapter state"},{"location":"adapters/Tribute/#dependencies-and-interactions-internal-external","text":"BankExtension Registers DAO internal token to be minted to the applicant in adapter configuration. Checks if tribute token (ERC-20) is registered with the DAO Bank. Registers tribute token for a passed proposal (if not already registered). Adds to the Guild balance the amount of tribute tokens. Checks if the DAO internal token to be minted to the applicant is registered with the DAO Bank. Adds to the applicant balance the amount of requested DAO internal tokens. DaoRegistry Gets Bank extension address. Checks if applicant address is not reserved. Gets Voting adapter address. Submits/sponsors/processes the tribute proposal. Checks if proposal flag is SPONSORED , PROCESSED . Creates a new member entry (if applicant is not already a member). Voting Gets address that sent the sponsorProposal transaction. Starts new voting for the tribute proposal. Checks the voting results.","title":"Dependencies and interactions (internal / external)"},{"location":"adapters/Tribute/#functions-description-and-assumptions-checks","text":"","title":"Functions description and assumptions / checks"},{"location":"adapters/Tribute/#receive-external-payable","text":"/** * @notice default fallback function to prevent from sending ether to the contract. */ receive() external payable","title":"receive() external payable"},{"location":"adapters/Tribute/#function-configuredao","text":"/** * @notice Configures the adapter for a particular DAO. * @notice Registers the DAO internal token with the DAO Bank. * @dev Only adapters registered to the DAO can execute the function call (or if the DAO is in creation mode). * @dev A DAO Bank extension must exist and be configured with proper access for this adapter. * @param dao The DAO address. * @param tokenAddrToMint The internal token address to be registered with the DAO Bank. */ function configureDao(DaoRegistry dao, address tokenAddrToMint) external onlyAdapter(dao)","title":"function configureDao"},{"location":"adapters/Tribute/#function-submitproposal","text":"/** * @notice Creates and sponsors a tribute proposal to start the voting process. * @dev Applicant address must not be reserved. * @dev Only members of the DAO can sponsor a tribute proposal. * @param dao The DAO address. * @param proposalId The proposal id (managed by the client). * @param applicant The applicant address (who will receive the DAO internal tokens and become a member). * @param tokenToMint The address of the DAO internal token to be minted to the applicant. * @param requestAmount The amount requested of DAO internal tokens. * @param tokenAddr The address of the ERC-20 tokens that will be transferred to the DAO in exchange for DAO internal tokens. * @param tributeAmount The amount of tribute tokens. * @param tributeTokenOwner The owner of the ERC-20 tokens being provided as tribute. * @param data Additional information related to the tribute proposal. */ function submitProposal( DaoRegistry dao, bytes32 proposalId, address applicant, address tokenToMint, uint256 requestAmount, address tokenAddr, uint256 tributeAmount, address tributeTokenOwner, bytes memory data ) external reentrancyGuard(dao)","title":"function submitProposal"},{"location":"adapters/Tribute/#function-processproposal","text":"/** * @notice Processes a tribute proposal to handle minting and exchange of DAO internal tokens for tribute tokens (passed vote). * @dev Proposal id must exist. * @dev Only proposals that have not already been processed are accepted. * @dev Only sponsored proposals with completed voting are accepted. * @dev The owner of the ERC-20 tokens provided as tribute must first separately `approve` the adapter as spender of those tokens (so the tokens can be transferred for a passed vote). * @dev ERC-20 tribute tokens must be registered with the DAO Bank (a passed proposal will check and register the token if needed). * @param dao The DAO address. * @param proposalId The proposal id. */ function processProposal(DaoRegistry dao, bytes32 proposalId) external reentrancyGuard(dao)","title":"function processProposal"},{"location":"adapters/Tribute/#events","text":"No events are emitted from this adapter.","title":"Events"},{"location":"adapters/TributeNFT/","text":"Adapter description and scope The Tribute NFT adapter allows potential and existing DAO members to contribute any ERC-721 tokens to the DAO in exchange for any amount of DAO internal tokens (in this case it mints UNITS always). If the proposal passes, the requested internal tokens are minted to the applicant (which effectively makes the applicant a member of the DAO if not already one) and the ERC-721 asset provided as tribute is transferred to the NFT extension. The Tribute NFT adapter is similar to the Onboarding adapter in that both allow for joining the DAO (or increasing a stake in the DAO) through the exchange of contributed assets for DAO internal tokens. However, there are key differences: The Onboarding adapter allows both Ether and ERC-20 tokens to be contributed. The Tribute NFT adapter accepts only ERC-721 tokens. The Onboarding adapter mints a fixed amount of internal tokens to the applicant based on the amount of assets contributed. In other words, an onboarding proposal does not specify the amount of internal tokens requested. That is calculated from the DAO's configurations and the amount of assets contributed. The Tribute NFT adapter has more open-ended proposal parameters. The proposer can request any amount of internal tokens to be minted in exchange for an ERC-721 token contributed. The worthiness of that transfer proposal for the DAO is left to the vote of its members. Adapter workflow A tribute is made by a member first submitting a proposal specifying (1) the applicant who wishes to join the DAO (or increase his stake in the DAO), (2) the amount of internal tokens (UNITS) the applicant desires, and (3) the ERC-721 address and token id of the NFT that will transfer to the DAO in exchange for those internal tokens. The applicant and actual owner of the NFT can be separate accounts (e.g., the NFT owner is providing tribute on behalf of the applicant). The proposal submission does not actually transfer the ERC-721 token from its owner. That occurs only after the proposal passes and is processed. The proposal is also sponsored in the same transaction when it is submitted. When a DAO member sponsors the proposal, the voting period begins allowing members to vote for or against the proposal. Only a member can sponsor the proposal. After the voting period is done along with its subsequent grace period, the proposal can be processed. Any account can process the proposal. However, prior to processing a passed proposal, the ERC-721 token owner must first separately approve the NFT extension as spender of the token provided as tribute. Upon processing, if the vote has passed, the requested internal tokens are minted to the applicant (which effectively makes the applicant a member of the DAO if not already one). The tribute token is transferred from the token owner to the NFT extension. Upon processing, if the vote has failed (i.e., more NO votes then YES votes or a tie), no further action is taken (the ERC-721 token owner still retains ownership of the token). Adapter configuration A DAO NFT extension and a DAO Bank extension must exist and be configured with proper access for this adapter. The DAO internal tokens (in this case UNITS) to be minted to the applicant must be registered with the DAO Bank. DAORegistry Access Flags: SUBMIT_PROPOSAL , NEW_MEMBER . NFT Extension Access Flags: COLLECT_NFT . Bank Extension Access Flags: ADD_TO_BALANCE . Adapter state proposals : All tribute NFT proposals handled by each DAO. ProposalDetails : id : The proposal id. applicant : The applicant address (who will receive the DAO internal tokens and become a member; this address may be different than the actual owner of the ERC-721 token being provided as tribute). nftAddr : The address of the ERC-721 token that will be transferred to the DAO in exchange for DAO internal tokens. nftTokenId : The NFT token identifier. requestAmount : The amount requested of DAO internal tokens (UNITS). Dependencies and interactions (internal / external) BankExtension Registers DAO internal token (in this case UNITS) to be minted to the applicant in adapter configuration. Adds to the applicant balance the amount of requested DAO internal tokens. NFTExtension Transfers the NFT asset from the owner to the NFT extension collection. DaoRegistry Gets Bank extension address. Checks if applicant address is not reserved. Gets Voting adapter address. Submits/sponsors/processes the tribute proposal. Checks if proposal flag is SPONSORED , PROCESSED . Creates a new member entry (if applicant is not already a member). Voting Gets address that sent the sponsorProposal transaction. Starts new voting for the tribute proposal. Checks the voting results. Functions description and assumptions / checks receive() external payable /** * @notice default fallback function to prevent from sending ether to the contract. */ receive() external payable function configureDao /** * @notice Configures the adapter for a particular DAO. * @notice Registers the DAO internal token UNITS with the DAO Bank. * @dev Only adapters registered to the DAO can execute the function call (or if the DAO is in creation mode). * @dev A DAO Bank extension must exist and be configured with proper access for this adapter. * @param dao The DAO address. */ function configureDao(DaoRegistry dao) external onlyAdapter(dao) function submitProposal /** * @notice Creates and sponsors a tribute proposal to start the voting process. * @dev Applicant address must not be reserved. * @dev Only members of the DAO can sponsor a tribute proposal. * @param dao The DAO address. * @param proposalId The proposal id (managed by the client). * @param applicant The applicant address (who will receive the DAO internal tokens and become a member). * @param nftAddr The address of the ERC-721 token that will be transferred to the DAO in exchange for DAO internal tokens. * @param nftTokenId The NFT token id. * @param requestAmount The amount requested of DAO internal tokens (UNITS). * @param data Additional information related to the tribute proposal. */ function submitProposal( DaoRegistry dao, bytes32 proposalId, address applicant, address nftAddr, uint256 nftTokenId, uint256 requestAmount bytes memory data ) external reentrancyGuard(dao) function processProposal /** * @notice Processes the proposal to handle minting and exchange of DAO internal tokens for tribute token (passed vote). * @dev Proposal id must exist. * @dev Only proposals that have not already been processed are accepted. * @dev Only sponsored proposals with completed voting are accepted. * @dev The owner of the ERC-721 token provided as tribute must first separately `approve` the NFT extension as spender of that token (so the NFT can be transferred for a passed vote). * @param dao The DAO address. * @param proposalId The proposal id. */ function processProposal(DaoRegistry dao, bytes32 proposalId) external reentrancyGuard(dao) Events No events are emitted from this adapter.","title":"TributeNFT"},{"location":"adapters/TributeNFT/#adapter-description-and-scope","text":"The Tribute NFT adapter allows potential and existing DAO members to contribute any ERC-721 tokens to the DAO in exchange for any amount of DAO internal tokens (in this case it mints UNITS always). If the proposal passes, the requested internal tokens are minted to the applicant (which effectively makes the applicant a member of the DAO if not already one) and the ERC-721 asset provided as tribute is transferred to the NFT extension. The Tribute NFT adapter is similar to the Onboarding adapter in that both allow for joining the DAO (or increasing a stake in the DAO) through the exchange of contributed assets for DAO internal tokens. However, there are key differences: The Onboarding adapter allows both Ether and ERC-20 tokens to be contributed. The Tribute NFT adapter accepts only ERC-721 tokens. The Onboarding adapter mints a fixed amount of internal tokens to the applicant based on the amount of assets contributed. In other words, an onboarding proposal does not specify the amount of internal tokens requested. That is calculated from the DAO's configurations and the amount of assets contributed. The Tribute NFT adapter has more open-ended proposal parameters. The proposer can request any amount of internal tokens to be minted in exchange for an ERC-721 token contributed. The worthiness of that transfer proposal for the DAO is left to the vote of its members.","title":"Adapter description and scope"},{"location":"adapters/TributeNFT/#adapter-workflow","text":"A tribute is made by a member first submitting a proposal specifying (1) the applicant who wishes to join the DAO (or increase his stake in the DAO), (2) the amount of internal tokens (UNITS) the applicant desires, and (3) the ERC-721 address and token id of the NFT that will transfer to the DAO in exchange for those internal tokens. The applicant and actual owner of the NFT can be separate accounts (e.g., the NFT owner is providing tribute on behalf of the applicant). The proposal submission does not actually transfer the ERC-721 token from its owner. That occurs only after the proposal passes and is processed. The proposal is also sponsored in the same transaction when it is submitted. When a DAO member sponsors the proposal, the voting period begins allowing members to vote for or against the proposal. Only a member can sponsor the proposal. After the voting period is done along with its subsequent grace period, the proposal can be processed. Any account can process the proposal. However, prior to processing a passed proposal, the ERC-721 token owner must first separately approve the NFT extension as spender of the token provided as tribute. Upon processing, if the vote has passed, the requested internal tokens are minted to the applicant (which effectively makes the applicant a member of the DAO if not already one). The tribute token is transferred from the token owner to the NFT extension. Upon processing, if the vote has failed (i.e., more NO votes then YES votes or a tie), no further action is taken (the ERC-721 token owner still retains ownership of the token).","title":"Adapter workflow"},{"location":"adapters/TributeNFT/#adapter-configuration","text":"A DAO NFT extension and a DAO Bank extension must exist and be configured with proper access for this adapter. The DAO internal tokens (in this case UNITS) to be minted to the applicant must be registered with the DAO Bank. DAORegistry Access Flags: SUBMIT_PROPOSAL , NEW_MEMBER . NFT Extension Access Flags: COLLECT_NFT . Bank Extension Access Flags: ADD_TO_BALANCE .","title":"Adapter configuration"},{"location":"adapters/TributeNFT/#adapter-state","text":"proposals : All tribute NFT proposals handled by each DAO. ProposalDetails : id : The proposal id. applicant : The applicant address (who will receive the DAO internal tokens and become a member; this address may be different than the actual owner of the ERC-721 token being provided as tribute). nftAddr : The address of the ERC-721 token that will be transferred to the DAO in exchange for DAO internal tokens. nftTokenId : The NFT token identifier. requestAmount : The amount requested of DAO internal tokens (UNITS).","title":"Adapter state"},{"location":"adapters/TributeNFT/#dependencies-and-interactions-internal-external","text":"BankExtension Registers DAO internal token (in this case UNITS) to be minted to the applicant in adapter configuration. Adds to the applicant balance the amount of requested DAO internal tokens. NFTExtension Transfers the NFT asset from the owner to the NFT extension collection. DaoRegistry Gets Bank extension address. Checks if applicant address is not reserved. Gets Voting adapter address. Submits/sponsors/processes the tribute proposal. Checks if proposal flag is SPONSORED , PROCESSED . Creates a new member entry (if applicant is not already a member). Voting Gets address that sent the sponsorProposal transaction. Starts new voting for the tribute proposal. Checks the voting results.","title":"Dependencies and interactions (internal / external)"},{"location":"adapters/TributeNFT/#functions-description-and-assumptions-checks","text":"","title":"Functions description and assumptions / checks"},{"location":"adapters/TributeNFT/#receive-external-payable","text":"/** * @notice default fallback function to prevent from sending ether to the contract. */ receive() external payable","title":"receive() external payable"},{"location":"adapters/TributeNFT/#function-configuredao","text":"/** * @notice Configures the adapter for a particular DAO. * @notice Registers the DAO internal token UNITS with the DAO Bank. * @dev Only adapters registered to the DAO can execute the function call (or if the DAO is in creation mode). * @dev A DAO Bank extension must exist and be configured with proper access for this adapter. * @param dao The DAO address. */ function configureDao(DaoRegistry dao) external onlyAdapter(dao)","title":"function configureDao"},{"location":"adapters/TributeNFT/#function-submitproposal","text":"/** * @notice Creates and sponsors a tribute proposal to start the voting process. * @dev Applicant address must not be reserved. * @dev Only members of the DAO can sponsor a tribute proposal. * @param dao The DAO address. * @param proposalId The proposal id (managed by the client). * @param applicant The applicant address (who will receive the DAO internal tokens and become a member). * @param nftAddr The address of the ERC-721 token that will be transferred to the DAO in exchange for DAO internal tokens. * @param nftTokenId The NFT token id. * @param requestAmount The amount requested of DAO internal tokens (UNITS). * @param data Additional information related to the tribute proposal. */ function submitProposal( DaoRegistry dao, bytes32 proposalId, address applicant, address nftAddr, uint256 nftTokenId, uint256 requestAmount bytes memory data ) external reentrancyGuard(dao)","title":"function submitProposal"},{"location":"adapters/TributeNFT/#function-processproposal","text":"/** * @notice Processes the proposal to handle minting and exchange of DAO internal tokens for tribute token (passed vote). * @dev Proposal id must exist. * @dev Only proposals that have not already been processed are accepted. * @dev Only sponsored proposals with completed voting are accepted. * @dev The owner of the ERC-721 token provided as tribute must first separately `approve` the NFT extension as spender of that token (so the NFT can be transferred for a passed vote). * @param dao The DAO address. * @param proposalId The proposal id. */ function processProposal(DaoRegistry dao, bytes32 proposalId) external reentrancyGuard(dao)","title":"function processProposal"},{"location":"adapters/TributeNFT/#events","text":"No events are emitted from this adapter.","title":"Events"},{"location":"adapters/Voting/","text":"Adapter description and scope This adapter manages on chain \"simple\" voting. Adapter state struct Voting { uint256 nbYes; uint256 nbNo; uint256 startingTime; uint256 blockNumber; mapping(address => uint256) votes; } nbYes: how many yes have been casted nbNo: how many no have been casted startingTime: starting time of the voting process mapping of member => vote to keep track of everybody's vote and know if they have already voted or not mapping(address => mapping(bytes32 => Voting)) public votes; mapping for each adapter of proposalId => voting state where voting state is Adapter configuration Two configurations are possible for the voting adapter: VotingPeriod = keccak256(\"voting.votingPeriod\") How long after the starting time is the voting valid GracePeriod = keccak256(\"voting.gracePeriod\") How long after the end of the voting period is the result settled Functions description, assumptions, checks, dependencies, interactions and access control function startNewVotingForProposal(DaoRegistry dao, bytes32 proposalId, bytes calldata) This is called every time a proposal is being sponsored. This starts the voting process. We assume here that the adapter uses dao.sponsorProposal() to make sure it is not called multiple times on the same proposal. function getSenderAddress(DaoRegistry, address, bytes memory, address sender) returns (address) This function allows the voting adapter determine who is signing the message based on the data sent. In the case of Voting, it's always msg.sender . But for other implementations, signed data could be used to determine it and let a relayer do the call. function submitVote(DaoRegistry dao, bytes32 proposalId, uint256 voteValue) Casts a vote. Only a member can submit a vote. We check that: The proposal has been sponsored The proposal has not been processed yet The vote has started (startingTime > 0) The vote has not ended yet The member has not voted yet The vote is valid (only either yes or no) function voteResult(DaoRegistry dao, bytes32 proposalId) returns (VotingState state) Gets back the vote result for a certain proposal. If the vote has not started yet, return NOT_STARTED . If the vote is still on going (after starting time but before startingTime + voting period) return IN_PROGRESS . If the vote has ended but is still in grace period, return GRACE_PERIOD . If none of the above and more yes votes than no votes, return PASS . If more no votes than yes votes, return NOT_PASS . If yes votes equals no votes, return TIE .","title":"Voting"},{"location":"adapters/Voting/#adapter-description-and-scope","text":"This adapter manages on chain \"simple\" voting.","title":"Adapter description and scope"},{"location":"adapters/Voting/#adapter-state","text":"struct Voting { uint256 nbYes; uint256 nbNo; uint256 startingTime; uint256 blockNumber; mapping(address => uint256) votes; } nbYes: how many yes have been casted nbNo: how many no have been casted startingTime: starting time of the voting process mapping of member => vote to keep track of everybody's vote and know if they have already voted or not mapping(address => mapping(bytes32 => Voting)) public votes; mapping for each adapter of proposalId => voting state where voting state is","title":"Adapter state"},{"location":"adapters/Voting/#adapter-configuration","text":"Two configurations are possible for the voting adapter:","title":"Adapter configuration"},{"location":"adapters/Voting/#votingperiod-keccak256votingvotingperiod","text":"How long after the starting time is the voting valid","title":"VotingPeriod = keccak256(\"voting.votingPeriod\")"},{"location":"adapters/Voting/#graceperiod-keccak256votinggraceperiod","text":"How long after the end of the voting period is the result settled","title":"GracePeriod = keccak256(\"voting.gracePeriod\")"},{"location":"adapters/Voting/#functions-description-assumptions-checks-dependencies-interactions-and-access-control","text":"","title":"Functions description, assumptions, checks, dependencies, interactions and access control"},{"location":"adapters/Voting/#function-startnewvotingforproposaldaoregistry-dao-bytes32-proposalid-bytes-calldata","text":"This is called every time a proposal is being sponsored. This starts the voting process. We assume here that the adapter uses dao.sponsorProposal() to make sure it is not called multiple times on the same proposal.","title":"function startNewVotingForProposal(DaoRegistry dao, bytes32 proposalId, bytes calldata)"},{"location":"adapters/Voting/#function-getsenderaddressdaoregistry-address-bytes-memory-address-sender-returns-address","text":"This function allows the voting adapter determine who is signing the message based on the data sent. In the case of Voting, it's always msg.sender . But for other implementations, signed data could be used to determine it and let a relayer do the call.","title":"function getSenderAddress(DaoRegistry, address, bytes memory, address sender) returns (address)"},{"location":"adapters/Voting/#function-submitvotedaoregistry-dao-bytes32-proposalid-uint256-votevalue","text":"Casts a vote. Only a member can submit a vote. We check that: The proposal has been sponsored The proposal has not been processed yet The vote has started (startingTime > 0) The vote has not ended yet The member has not voted yet The vote is valid (only either yes or no)","title":"function submitVote(DaoRegistry dao, bytes32 proposalId, uint256 voteValue)"},{"location":"adapters/Voting/#function-voteresultdaoregistry-dao-bytes32-proposalid-returns-votingstate-state","text":"Gets back the vote result for a certain proposal. If the vote has not started yet, return NOT_STARTED . If the vote is still on going (after starting time but before startingTime + voting period) return IN_PROGRESS . If the vote has ended but is still in grace period, return GRACE_PERIOD . If none of the above and more yes votes than no votes, return PASS . If more no votes than yes votes, return NOT_PASS . If yes votes equals no votes, return TIE .","title":"function voteResult(DaoRegistry dao, bytes32 proposalId) returns (VotingState state)"},{"location":"adapters/Withdraw/","text":"Adapter description and scope The Withdraw adapter allows a member or an advisor of the DAO to withdraw the available funds in their bank account. It is considered a Generic adapter because it does not rely on any proposals to perform an action that changes the DAO state. Adapter workflow The user sends a transaction to withdraw the funds from the internal bank account. If there are no available funds, the transaction is reverted. If the user is using an address that is reserved to the DAO, the transaction is also reverted. And when the user provides a token that is not supported by the bank, the balance is always zero and the transaction gets reverted as well. If all the parameters are valid, the user should be able to identify the funds transferred to its own account. Adapter configuration Bank Extension Access Flags: WITHDRAW , SUB_FROM_BALANCE . Adapter state The adapter does not keep track of any state during the withdraw process. Dependencies and interactions (internal / external) BankExtension Checks the account balance. Executes the withdraw process. DAORegistry Checks if the account address is not a reserved address. Functions description and assumptions / checks receive() external payable /** * @notice default fallback function to prevent from sending ether to the contract */ receive() external payable function withdraw /** * @notice Allows the member/advisor of the DAO to withdraw the funds from their internal bank account. * @notice Only accounts that are not reserved can withdraw the funds. * @notice If theres is no available balance in the user's account, the transaction is reverted. * @param dao The DAO address. * @param account The account to receive the funds. * @param token The token address to receive the funds. */ function withdraw( DaoRegistry dao, address payable account, address token ) external Events No events are emitted from this adapter.","title":"Withdraw"},{"location":"adapters/Withdraw/#adapter-description-and-scope","text":"The Withdraw adapter allows a member or an advisor of the DAO to withdraw the available funds in their bank account. It is considered a Generic adapter because it does not rely on any proposals to perform an action that changes the DAO state.","title":"Adapter description and scope"},{"location":"adapters/Withdraw/#adapter-workflow","text":"The user sends a transaction to withdraw the funds from the internal bank account. If there are no available funds, the transaction is reverted. If the user is using an address that is reserved to the DAO, the transaction is also reverted. And when the user provides a token that is not supported by the bank, the balance is always zero and the transaction gets reverted as well. If all the parameters are valid, the user should be able to identify the funds transferred to its own account.","title":"Adapter workflow"},{"location":"adapters/Withdraw/#adapter-configuration","text":"Bank Extension Access Flags: WITHDRAW , SUB_FROM_BALANCE .","title":"Adapter configuration"},{"location":"adapters/Withdraw/#adapter-state","text":"The adapter does not keep track of any state during the withdraw process.","title":"Adapter state"},{"location":"adapters/Withdraw/#dependencies-and-interactions-internal-external","text":"BankExtension Checks the account balance. Executes the withdraw process. DAORegistry Checks if the account address is not a reserved address.","title":"Dependencies and interactions (internal / external)"},{"location":"adapters/Withdraw/#functions-description-and-assumptions-checks","text":"","title":"Functions description and assumptions / checks"},{"location":"adapters/Withdraw/#receive-external-payable","text":"/** * @notice default fallback function to prevent from sending ether to the contract */ receive() external payable","title":"receive() external payable"},{"location":"adapters/Withdraw/#function-withdraw","text":"/** * @notice Allows the member/advisor of the DAO to withdraw the funds from their internal bank account. * @notice Only accounts that are not reserved can withdraw the funds. * @notice If theres is no available balance in the user's account, the transaction is reverted. * @param dao The DAO address. * @param account The account to receive the funds. * @param token The token address to receive the funds. */ function withdraw( DaoRegistry dao, address payable account, address token ) external","title":"function withdraw"},{"location":"adapters/Withdraw/#events","text":"No events are emitted from this adapter.","title":"Events"},{"location":"core/DaoFactory/","text":"DaoFactory description and scope The DaoFactory uses the CloneFactory to let you create a cost effective DaoRegistry and initialize and configure it properly. It also serves as a registry of created DAOs to help others find a DAO by name. DaoFactory state The state consists of two mappings to get the sha3(name) of a DAO given an address and the address given the sha3(name). mapping(address => bytes32) public daos mapping(bytes32 => address) public addresses We also have the address of the identityDao address public identityAddress that is being used to clone the DAO. Functions description and assumptions / checks function createDao /** * @notice Creates and initializes a new DaoRegistry with the DAO creator and the transaction sender. * @notice Enters the new DaoRegistry in the DaoFactory state. * @dev The daoName must not already have been taken. * @param daoName The name of the DAO which, after being hashed, is used to access the address. * @param creator The DAO's creator, who will be an initial member. */ function createDao(string calldata daoName, address creator) external function getDaoAddress /** * @notice Returns the DAO address based on its name. * @return The address of a DAO, given its name. * @param daoName Name of the DAO to be searched. */ function getDaoAddress(string calldata daoName) public view returns (address) function addAdapters /** * @notice Adds adapters and sets their ACL for DaoRegistry functions. * @dev A new DAO is instantiated with only the Core Modules enabled, to reduce the call cost. This call must be made to add adapters. * @dev The message sender must be an active member of the DAO. * @dev The DAO must be in `CREATION` state. * @param dao DaoRegistry to have adapters added to. * @param adapters Adapter structs to be added to the DAO. */ function addAdapters(DaoRegistry dao, Adapter[] calldata adapters) external function configureExtension /** * @notice Configures extension to set the ACL for each adapter that needs to access the extension. * @dev The message sender must be an active member of the DAO. * @dev The DAO must be in `CREATION` state. * @param dao DaoRegistry for which the extension is being configured. * @param extension The address of the extension to be configured. * @param adapters Adapter structs for which the ACL is being set for the extension. */ function configureExtension( DaoRegistry dao, address extension, Adapter[] calldata adapters ) external function updateAdapter /** * @notice Removes an adapter with a given ID from a DAO, and adds a new one of the same ID. * @dev The message sender must be an active member of the DAO. * @dev The DAO must be in `CREATION` state. * @param dao DAO to be updated. * @param adapter Adapter that will be replacing the currently-existing adapter of the same ID. */ function updateAdapter(DaoRegistry dao, Adapter calldata adapter) external Events event DAOCreated /** * @notice Event emitted when a new DAO has been created. * @param _address The DAO address. * @param _name The DAO name. */ event DAOCreated(address _address, string _name)","title":"DaoFactory"},{"location":"core/DaoFactory/#daofactory-description-and-scope","text":"The DaoFactory uses the CloneFactory to let you create a cost effective DaoRegistry and initialize and configure it properly. It also serves as a registry of created DAOs to help others find a DAO by name.","title":"DaoFactory description and scope"},{"location":"core/DaoFactory/#daofactory-state","text":"The state consists of two mappings to get the sha3(name) of a DAO given an address and the address given the sha3(name). mapping(address => bytes32) public daos mapping(bytes32 => address) public addresses We also have the address of the identityDao address public identityAddress that is being used to clone the DAO.","title":"DaoFactory state"},{"location":"core/DaoFactory/#functions-description-and-assumptions-checks","text":"","title":"Functions description and assumptions / checks"},{"location":"core/DaoFactory/#function-createdao","text":"/** * @notice Creates and initializes a new DaoRegistry with the DAO creator and the transaction sender. * @notice Enters the new DaoRegistry in the DaoFactory state. * @dev The daoName must not already have been taken. * @param daoName The name of the DAO which, after being hashed, is used to access the address. * @param creator The DAO's creator, who will be an initial member. */ function createDao(string calldata daoName, address creator) external","title":"function createDao"},{"location":"core/DaoFactory/#function-getdaoaddress","text":"/** * @notice Returns the DAO address based on its name. * @return The address of a DAO, given its name. * @param daoName Name of the DAO to be searched. */ function getDaoAddress(string calldata daoName) public view returns (address)","title":"function getDaoAddress"},{"location":"core/DaoFactory/#function-addadapters","text":"/** * @notice Adds adapters and sets their ACL for DaoRegistry functions. * @dev A new DAO is instantiated with only the Core Modules enabled, to reduce the call cost. This call must be made to add adapters. * @dev The message sender must be an active member of the DAO. * @dev The DAO must be in `CREATION` state. * @param dao DaoRegistry to have adapters added to. * @param adapters Adapter structs to be added to the DAO. */ function addAdapters(DaoRegistry dao, Adapter[] calldata adapters) external","title":"function addAdapters"},{"location":"core/DaoFactory/#function-configureextension","text":"/** * @notice Configures extension to set the ACL for each adapter that needs to access the extension. * @dev The message sender must be an active member of the DAO. * @dev The DAO must be in `CREATION` state. * @param dao DaoRegistry for which the extension is being configured. * @param extension The address of the extension to be configured. * @param adapters Adapter structs for which the ACL is being set for the extension. */ function configureExtension( DaoRegistry dao, address extension, Adapter[] calldata adapters ) external","title":"function configureExtension"},{"location":"core/DaoFactory/#function-updateadapter","text":"/** * @notice Removes an adapter with a given ID from a DAO, and adds a new one of the same ID. * @dev The message sender must be an active member of the DAO. * @dev The DAO must be in `CREATION` state. * @param dao DAO to be updated. * @param adapter Adapter that will be replacing the currently-existing adapter of the same ID. */ function updateAdapter(DaoRegistry dao, Adapter calldata adapter) external","title":"function updateAdapter"},{"location":"core/DaoFactory/#events","text":"","title":"Events"},{"location":"core/DaoFactory/#event-daocreated","text":"/** * @notice Event emitted when a new DAO has been created. * @param _address The DAO address. * @param _name The DAO name. */ event DAOCreated(address _address, string _name)","title":"event DAOCreated"},{"location":"core/DaoRegistry/","text":"DaoRegistry description and scope The DAO Registry is the identity of the DAO. This is the contract address that is every adapter usually interacts with. The scope of the registry is to manage the following: The adapter registry - which adapter is being used by this DAO and which access it has to the DAO state. The extension registry - which extension is part of the DAO and the adapter's access to it. Members registry - whether members exist, their delegate key and their access flags. Each non-constant function in the DAO has an access control modifier linked to it, to make sure the caller has the right to call it. The DaoRegistry.sol contract tracks the state of the DAO for 1) Adapter and Extension access, 2) State of Proposals, 3) Membership status. For an Adapter to be used it must be registered to DaoRegistry.sol. Enums DAO State enum DaoState {CREATION, READY} CREATION = the DAO has been deployed via initializeDao , but is not ready to be used. READY = the function finalizeDao has been called and is now ready to be used. Once the DaoState = READY then the only way to add additional Adapters is to via the proposal process. Access Flags enum MemberFlag {EXISTS} = EXISTS is true if a member or a proposal exists. enum ProposalFlag {EXISTS, SPONSORED, PROCESSED} = EXISTS true if a proposal has been been submitted. SPONSORED is true if a Submitted proposal has been Sponsored by an existing Member. enum AclFlag { REPLACE_ADAPTER, SUBMIT_PROPOSAL, UPDATE_DELEGATE_KEY, SET_CONFIGURATION, ADD_EXTENSION, REMOVE_EXTENSION, NEW_MEMBER } REPLACE_ADAPTER - if true, the caller adapter has access to add, remove, and replace adapters in the DAO, function dao.replaceAdapter . SUBMIT_PROPOSAL - if true, the caller adapter is allowed to submit/create proposals in the DAO, function dao.submitProposal . UPDATE_DELEGATE_KEY - if true, the caller adapter has the access to update the member's delegated key in the DAO, function dao.updateDelegatedKey . SET_CONFIGURATION - if true, the caller adapter is allowed to store custom configurations as key/value in the DAO, function dao.setConfiguration . ADD_EXTENSION - if true, the caller adapter is allowed to add new Extensions to the DAO, function dao.addExtension . REMOVE_EXTENSION - if true, the caller adapter is allowed to remove Extensions from the DAO, function dao.removeExtension . NEW_MEMBER - if true, the caller adapter has access to register new members in the DAO, function dao.potentialNewMember . Events Events for Proposals - The proposal order follows Moloch v2, in 1) a proposal is submitted, 2) then it sponsored by a member, and 3) after a proposal is voted on, it can finally be processed. `event SubmittedProposal(bytes32 proposalId, uint256 flags);` `event SponsoredProposal(bytes32 proposalId, uint256 flags, address votingAdapter);` `event ProcessedProposal(bytes32 proposalId, uint256 flags);` Events for Adding and Removing Adapters `event AdapterAdded(bytes32 adapterId,address adapterAddress,uint256 flags);` `event AdapterRemoved(bytes32 adapterId);` Events for Members `event UpdateDelegateKey(address memberAddress, address newDelegateKey);` Configuration Events `event ConfigurationUpdated(bytes32 key, uint256 value);` `event AddressConfigurationUpdated(bytes32 key, address value);` Structs struct Proposal the structure to track all the proposals in the DAO and their state (EXISTS, SPONSORED, PROCESSED). struct Member the structure to track all the members in the DAO and their state (EXISTS). struct Checkpoint Tribute makes use of the off-chain voting mechanism Snapshot. The Checkpoint struct assists with verifying the optimistic voting and proposal mechanisms at various blocktimes. See, https://github.com/snapshot-labs. struct DelegateCheckpoint A checkpoint for marking number of votes from a given block. struct AdapterEntry When an Adapter is added to DaoRegistry via the function replaceAdapter , a bytes32 id and a uint256 acl are parameters assigned to the Adapter for use in identifying the Adapter. struct ExtensionEntry When an Extension is added to DaoRegistry via addExtenstion a bytes32 id and a uint256 acl are parameters assigned to the Extension for use in identifying the Extension. Registry state & Public Variables mapping(address => Member) public members Mapping of all the members. Member struct contains the flags uint. address[] private _members List of all the member addresses. Useful to iterate through members. mapping(address => address) public memberAddressesByDelegatedKey Mapping of the member address by delegate key (think inverted mapping from members by delegate key). mapping(address => mapping(uint32 => DelegateCheckpoint)) checkpoints Delegate key checkpoints. This is useful to know what the delegate key is at a certain point in time. mapping(address => uint32) numCheckpoints Checkpoint lengths per member address. DaoState public state Dao state. This is used to know if the DAO is currently being set up or if it is already running. Useful to configure it. mapping(bytes32 => Proposal) public proposals Mapping of all the proposals for the DAO. Each proposal has an adapterAddress (which adapter created it) and flags to define its state. mapping(bytes32 => address) public adapters Mapping of all the adapters. bytes32 is the keccak256 of their name and address. mapping(address => AdapterEntry) public inverseAdapters Mapping of adapter details. For each address, we can get its id (keccak256(name)) and its acl (access control, which function in the DAO it has access to). mapping(bytes32 => address) public extensions Mapping of each extension. Like for adapters, the key here is keccak256(name) (e.g., keccak256(\"bank\")) mapping(address => ExtensionEntry) public inverseExtensions Mapping of extension details. For each extension address, you get its id (keccak256(name)) and a mapping from adapter address => access control. Access control for each extension is centralized in the DaoRegistry to avoid each extension implementing its own ACL system. mapping(bytes32 => uint256) public mainConfiguration Generic configuration mapping from key (keccak256(name)) to any type that can be encoded in 256 bytes (does not need to be uint, could be bytes32 too). mapping(bytes32 => address) public addressConfiguration Since addresses are not encoded in 256 bytes, we need a separate configuration mapping for this type. Functions description, assumptions, checks, dependencies, interactions and access control Note: the constructor function is non-existent, because this is a Cloneable contract. See, https://eips.ethereum.org/EIPS/eip-1167 function initialize(address creator, address payer) external Initializes the DAO by creating the initial members who are 1) the DAO creator passed to the function, 2) the account passed to the function which paid for the transaction to create the DAO, and 3) the DaoFactory calling this function. function finalizeDao() Mark the DAO as finalized. After that, changes can only be made through adapters. function setConfiguration(bytes32 key, uint256 value) Set a generic configuration entry for the DAO. Only adapters with access to this function can do it. function setAddressConfiguration(bytes32 key, address value) Set an address configuration entry for the DAO. Only adapters with access to this function can do it. function potentialNewMember(address memberAddress) This functions checks if the member exists in the DAO. If the member does not exist, it creates the entry for the new member. That means creating an entry in the members mapping, setting the delegate key to be the same address as the new member and adding the address to the members list. function getConfiguration(bytes32 key) external view returns (uint256) Get the generic config entry by passing the keccak256(config name). function getAddressConfiguration(bytes32 key) Get the address config entry by passing the keccak256(config name). function addExtension(bytes32 extensionId, IExtension extension, address creator) external Add a new extension to the registry. It first checks if the extension id is already used and reverts if it is the case. It then adds the extension to the DAO and initializes it. function removeExtension(bytes32 extensionId) Removes the extension by extension id. It reverts if no extension has been registered for that id (keccak256(name)). function setAclToExtensionForAdapter(address extensionAddress, address adapterAddress, uint256 acl) Sets the access control for a particular adapter (by address) to a specific extension. Both adapter and extension need to be already registered to the DAO. function replaceAdapter(bytes32 adapterId, address adapterAddress, uint256 acl, bytes32[] calldata keys,uint256[] calldata values) Adds, removes or replaces an adapter om the DAO registry. It also sets the access control. The adapter can be added only if the adapter id is not already in use. To remove an adapter from the DAO just set the address to 0x0. function isExtension(address extensionAddr) public view returns (bool) Checks whether the address is registered as an extension in the DAO. function isAdapter(address adapterAddress) public view returns (bool) Checks whether the address is registered as an adapter in the DAO. function hasAdapterAccess(address adapterAddress, AclFlag flag) Checks whether the adapter has access to a certain flag in the DAO. function hasAdapterAccessToExtension(address adapterAddress, address extensionAddress, uint8 flag) returns (bool) Checks whether a certain adapter has access to a certain extension in the DAO. function getAdapterAddress(bytes32 adapterId) returns (address) Returns the adapter address registered for this adapterId and reverts if not found. The reason we revert here is to avoid the need to check everywhere that the return value is 0x0 when we want to use an adapter. function getExtensionAddress(bytes32 extensionId) external view returns (address) Returns the extension address registered for this extensionId and reverts if not found. The reason we revert here is to avoid the need to check everywhere that the return value is 0x0 when we want to use an extension. function submitProposal(bytes32 proposalId) Creates a proposal entry for the DAO. It checks that the proposal was not previously created. function sponsorProposal(bytes32 proposalId, address sponsoringMember, address votingAdapterAddress) Marks an existing proposal as sponsored. saves which voting adapter is being used for this proposal. Checks that the proposal has not been sponsored yet. Checks that the proposal exists. Checks that the adapter that sponsors the proposal is the one that submitted it. Checks that the proposal has not been processed yet. Checks that the member sponsoring the proposal is an active member. function processProposal(bytes32 proposalId) Marks an existing proposal as processed. Checks that the proposal has not been processed already and that it exists. function _setProposalFlag(bytes32 proposalId, ProposalFlag flag) Internal utility function to set a flag to a proposal. It checks that the proposal exists and that the flag has not been already set. function isMember(address addr) public view returns (bool) Returns true if the address is the delegate key of an existing member function getProposalFlag(bytes32 proposalId, ProposalFlag flag) returns (bool) Helper function to get the flag value for a proposal. function getMemberFlag(address memberAddress, MemberFlag flag) returns (bool) Helper function to get the flag value for a member. function getNbMembers() public view returns (uint256) Returns how many members have been registered in the DAO. function getMemberAddress(uint256 index) public view returns (address) Gets an address at a certain index in the members list. function updateDelegateKey(address memberAddr, address newDelegateKey) Updates the delegate key of a certain member. It checks that the delegate key is not being used by another member and is not the address of an existing member. It also checks that the member exists. If all the checks pass, the delegate key is updated and a delegate key checkpoint is created. function getAddressIfDelegated(address checkAddr) Returns the member address if the address is used as a delegate key or the address itself if it is not. function getCurrentDelegateKey(address memberAddr) returns (address) Returns the current delegate key for a member address. function getPreviousDelegateKey(address memberAddr) returns (address) Returns the previous delegate key for a member address. It is used to prepare the checkpoint. function getPriorDelegateKey(address memberAddr, uint256 blockNumber) returns (address) Returns the delegate key for a member at a certain block number. If none are found, the memberAddr is returned instead. function _createNewDelegateCheckpoint( address member, address newDelegateKey) internal Writes a new checkpoint for a specific member.","title":"DaoRegistry"},{"location":"core/DaoRegistry/#daoregistry-description-and-scope","text":"The DAO Registry is the identity of the DAO. This is the contract address that is every adapter usually interacts with. The scope of the registry is to manage the following: The adapter registry - which adapter is being used by this DAO and which access it has to the DAO state. The extension registry - which extension is part of the DAO and the adapter's access to it. Members registry - whether members exist, their delegate key and their access flags. Each non-constant function in the DAO has an access control modifier linked to it, to make sure the caller has the right to call it. The DaoRegistry.sol contract tracks the state of the DAO for 1) Adapter and Extension access, 2) State of Proposals, 3) Membership status. For an Adapter to be used it must be registered to DaoRegistry.sol.","title":"DaoRegistry description and scope"},{"location":"core/DaoRegistry/#enums","text":"","title":"Enums"},{"location":"core/DaoRegistry/#dao-state","text":"enum DaoState {CREATION, READY} CREATION = the DAO has been deployed via initializeDao , but is not ready to be used. READY = the function finalizeDao has been called and is now ready to be used. Once the DaoState = READY then the only way to add additional Adapters is to via the proposal process.","title":"DAO State"},{"location":"core/DaoRegistry/#access-flags","text":"enum MemberFlag {EXISTS} = EXISTS is true if a member or a proposal exists. enum ProposalFlag {EXISTS, SPONSORED, PROCESSED} = EXISTS true if a proposal has been been submitted. SPONSORED is true if a Submitted proposal has been Sponsored by an existing Member. enum AclFlag { REPLACE_ADAPTER, SUBMIT_PROPOSAL, UPDATE_DELEGATE_KEY, SET_CONFIGURATION, ADD_EXTENSION, REMOVE_EXTENSION, NEW_MEMBER } REPLACE_ADAPTER - if true, the caller adapter has access to add, remove, and replace adapters in the DAO, function dao.replaceAdapter . SUBMIT_PROPOSAL - if true, the caller adapter is allowed to submit/create proposals in the DAO, function dao.submitProposal . UPDATE_DELEGATE_KEY - if true, the caller adapter has the access to update the member's delegated key in the DAO, function dao.updateDelegatedKey . SET_CONFIGURATION - if true, the caller adapter is allowed to store custom configurations as key/value in the DAO, function dao.setConfiguration . ADD_EXTENSION - if true, the caller adapter is allowed to add new Extensions to the DAO, function dao.addExtension . REMOVE_EXTENSION - if true, the caller adapter is allowed to remove Extensions from the DAO, function dao.removeExtension . NEW_MEMBER - if true, the caller adapter has access to register new members in the DAO, function dao.potentialNewMember .","title":"Access Flags"},{"location":"core/DaoRegistry/#events","text":"Events for Proposals - The proposal order follows Moloch v2, in 1) a proposal is submitted, 2) then it sponsored by a member, and 3) after a proposal is voted on, it can finally be processed. `event SubmittedProposal(bytes32 proposalId, uint256 flags);` `event SponsoredProposal(bytes32 proposalId, uint256 flags, address votingAdapter);` `event ProcessedProposal(bytes32 proposalId, uint256 flags);` Events for Adding and Removing Adapters `event AdapterAdded(bytes32 adapterId,address adapterAddress,uint256 flags);` `event AdapterRemoved(bytes32 adapterId);` Events for Members `event UpdateDelegateKey(address memberAddress, address newDelegateKey);` Configuration Events `event ConfigurationUpdated(bytes32 key, uint256 value);` `event AddressConfigurationUpdated(bytes32 key, address value);`","title":"Events"},{"location":"core/DaoRegistry/#structs","text":"struct Proposal the structure to track all the proposals in the DAO and their state (EXISTS, SPONSORED, PROCESSED). struct Member the structure to track all the members in the DAO and their state (EXISTS). struct Checkpoint Tribute makes use of the off-chain voting mechanism Snapshot. The Checkpoint struct assists with verifying the optimistic voting and proposal mechanisms at various blocktimes. See, https://github.com/snapshot-labs. struct DelegateCheckpoint A checkpoint for marking number of votes from a given block. struct AdapterEntry When an Adapter is added to DaoRegistry via the function replaceAdapter , a bytes32 id and a uint256 acl are parameters assigned to the Adapter for use in identifying the Adapter. struct ExtensionEntry When an Extension is added to DaoRegistry via addExtenstion a bytes32 id and a uint256 acl are parameters assigned to the Extension for use in identifying the Extension.","title":"Structs"},{"location":"core/DaoRegistry/#registry-state-public-variables","text":"","title":"Registry state &amp; Public Variables"},{"location":"core/DaoRegistry/#mappingaddress-member-public-members","text":"Mapping of all the members. Member struct contains the flags uint.","title":"mapping(address =&gt; Member) public members"},{"location":"core/DaoRegistry/#address-private-_members","text":"List of all the member addresses. Useful to iterate through members.","title":"address[] private _members"},{"location":"core/DaoRegistry/#mappingaddress-address-public-memberaddressesbydelegatedkey","text":"Mapping of the member address by delegate key (think inverted mapping from members by delegate key).","title":"mapping(address =&gt; address) public memberAddressesByDelegatedKey"},{"location":"core/DaoRegistry/#mappingaddress-mappinguint32-delegatecheckpoint-checkpoints","text":"Delegate key checkpoints. This is useful to know what the delegate key is at a certain point in time.","title":"mapping(address =&gt; mapping(uint32 =&gt; DelegateCheckpoint)) checkpoints"},{"location":"core/DaoRegistry/#mappingaddress-uint32-numcheckpoints","text":"Checkpoint lengths per member address.","title":"mapping(address =&gt; uint32) numCheckpoints"},{"location":"core/DaoRegistry/#daostate-public-state","text":"Dao state. This is used to know if the DAO is currently being set up or if it is already running. Useful to configure it.","title":"DaoState public state"},{"location":"core/DaoRegistry/#mappingbytes32-proposal-public-proposals","text":"Mapping of all the proposals for the DAO. Each proposal has an adapterAddress (which adapter created it) and flags to define its state.","title":"mapping(bytes32 =&gt; Proposal) public proposals"},{"location":"core/DaoRegistry/#mappingbytes32-address-public-adapters","text":"Mapping of all the adapters. bytes32 is the keccak256 of their name and address.","title":"mapping(bytes32 =&gt; address) public adapters"},{"location":"core/DaoRegistry/#mappingaddress-adapterentry-public-inverseadapters","text":"Mapping of adapter details. For each address, we can get its id (keccak256(name)) and its acl (access control, which function in the DAO it has access to).","title":"mapping(address =&gt; AdapterEntry) public inverseAdapters"},{"location":"core/DaoRegistry/#mappingbytes32-address-public-extensions","text":"Mapping of each extension. Like for adapters, the key here is keccak256(name) (e.g., keccak256(\"bank\"))","title":"mapping(bytes32 =&gt; address) public extensions"},{"location":"core/DaoRegistry/#mappingaddress-extensionentry-public-inverseextensions","text":"Mapping of extension details. For each extension address, you get its id (keccak256(name)) and a mapping from adapter address => access control. Access control for each extension is centralized in the DaoRegistry to avoid each extension implementing its own ACL system.","title":"mapping(address =&gt; ExtensionEntry) public inverseExtensions"},{"location":"core/DaoRegistry/#mappingbytes32-uint256-public-mainconfiguration","text":"Generic configuration mapping from key (keccak256(name)) to any type that can be encoded in 256 bytes (does not need to be uint, could be bytes32 too).","title":"mapping(bytes32 =&gt; uint256) public mainConfiguration"},{"location":"core/DaoRegistry/#mappingbytes32-address-public-addressconfiguration","text":"Since addresses are not encoded in 256 bytes, we need a separate configuration mapping for this type.","title":"mapping(bytes32 =&gt; address) public addressConfiguration"},{"location":"core/DaoRegistry/#functions-description-assumptions-checks-dependencies-interactions-and-access-control","text":"Note: the constructor function is non-existent, because this is a Cloneable contract. See, https://eips.ethereum.org/EIPS/eip-1167","title":"Functions description, assumptions, checks, dependencies, interactions and access control"},{"location":"core/DaoRegistry/#function-initializeaddress-creator-address-payer-external","text":"Initializes the DAO by creating the initial members who are 1) the DAO creator passed to the function, 2) the account passed to the function which paid for the transaction to create the DAO, and 3) the DaoFactory calling this function.","title":"function initialize(address creator, address payer) external"},{"location":"core/DaoRegistry/#function-finalizedao","text":"Mark the DAO as finalized. After that, changes can only be made through adapters.","title":"function finalizeDao()"},{"location":"core/DaoRegistry/#function-setconfigurationbytes32-key-uint256-value","text":"Set a generic configuration entry for the DAO. Only adapters with access to this function can do it.","title":"function setConfiguration(bytes32 key, uint256 value)"},{"location":"core/DaoRegistry/#function-setaddressconfigurationbytes32-key-address-value","text":"Set an address configuration entry for the DAO. Only adapters with access to this function can do it.","title":"function setAddressConfiguration(bytes32 key, address value)"},{"location":"core/DaoRegistry/#function-potentialnewmemberaddress-memberaddress","text":"This functions checks if the member exists in the DAO. If the member does not exist, it creates the entry for the new member. That means creating an entry in the members mapping, setting the delegate key to be the same address as the new member and adding the address to the members list.","title":"function potentialNewMember(address memberAddress)"},{"location":"core/DaoRegistry/#function-getconfigurationbytes32-key-external-view-returns-uint256","text":"Get the generic config entry by passing the keccak256(config name).","title":"function getConfiguration(bytes32 key) external view returns (uint256)"},{"location":"core/DaoRegistry/#function-getaddressconfigurationbytes32-key","text":"Get the address config entry by passing the keccak256(config name).","title":"function getAddressConfiguration(bytes32 key)"},{"location":"core/DaoRegistry/#function-addextensionbytes32-extensionid-iextension-extension-address-creator-external","text":"Add a new extension to the registry. It first checks if the extension id is already used and reverts if it is the case. It then adds the extension to the DAO and initializes it.","title":"function addExtension(bytes32 extensionId, IExtension extension, address creator) external"},{"location":"core/DaoRegistry/#function-removeextensionbytes32-extensionid","text":"Removes the extension by extension id. It reverts if no extension has been registered for that id (keccak256(name)).","title":"function removeExtension(bytes32 extensionId)"},{"location":"core/DaoRegistry/#function-setacltoextensionforadapteraddress-extensionaddress-address-adapteraddress-uint256-acl","text":"Sets the access control for a particular adapter (by address) to a specific extension. Both adapter and extension need to be already registered to the DAO.","title":"function setAclToExtensionForAdapter(address extensionAddress, address adapterAddress, uint256 acl)"},{"location":"core/DaoRegistry/#function-replaceadapterbytes32-adapterid-address-adapteraddress-uint256-acl-bytes32-calldata-keysuint256-calldata-values","text":"Adds, removes or replaces an adapter om the DAO registry. It also sets the access control. The adapter can be added only if the adapter id is not already in use. To remove an adapter from the DAO just set the address to 0x0.","title":"function replaceAdapter(bytes32 adapterId, address adapterAddress, uint256 acl, bytes32[] calldata keys,uint256[] calldata values)"},{"location":"core/DaoRegistry/#function-isextensionaddress-extensionaddr-public-view-returns-bool","text":"Checks whether the address is registered as an extension in the DAO.","title":"function isExtension(address extensionAddr) public view returns (bool)"},{"location":"core/DaoRegistry/#function-isadapteraddress-adapteraddress-public-view-returns-bool","text":"Checks whether the address is registered as an adapter in the DAO.","title":"function isAdapter(address adapterAddress) public view returns (bool)"},{"location":"core/DaoRegistry/#function-hasadapteraccessaddress-adapteraddress-aclflag-flag","text":"Checks whether the adapter has access to a certain flag in the DAO.","title":"function hasAdapterAccess(address adapterAddress, AclFlag flag)"},{"location":"core/DaoRegistry/#function-hasadapteraccesstoextensionaddress-adapteraddress-address-extensionaddress-uint8-flag-returns-bool","text":"Checks whether a certain adapter has access to a certain extension in the DAO.","title":"function hasAdapterAccessToExtension(address adapterAddress, address extensionAddress, uint8 flag) returns (bool)"},{"location":"core/DaoRegistry/#function-getadapteraddressbytes32-adapterid-returns-address","text":"Returns the adapter address registered for this adapterId and reverts if not found. The reason we revert here is to avoid the need to check everywhere that the return value is 0x0 when we want to use an adapter.","title":"function getAdapterAddress(bytes32 adapterId) returns (address)"},{"location":"core/DaoRegistry/#function-getextensionaddressbytes32-extensionid-external-view-returns-address","text":"Returns the extension address registered for this extensionId and reverts if not found. The reason we revert here is to avoid the need to check everywhere that the return value is 0x0 when we want to use an extension.","title":"function getExtensionAddress(bytes32 extensionId) external view returns (address)"},{"location":"core/DaoRegistry/#function-submitproposalbytes32-proposalid","text":"Creates a proposal entry for the DAO. It checks that the proposal was not previously created.","title":"function submitProposal(bytes32 proposalId)"},{"location":"core/DaoRegistry/#function-sponsorproposalbytes32-proposalid-address-sponsoringmember-address-votingadapteraddress","text":"Marks an existing proposal as sponsored. saves which voting adapter is being used for this proposal. Checks that the proposal has not been sponsored yet. Checks that the proposal exists. Checks that the adapter that sponsors the proposal is the one that submitted it. Checks that the proposal has not been processed yet. Checks that the member sponsoring the proposal is an active member.","title":"function sponsorProposal(bytes32 proposalId, address sponsoringMember, address votingAdapterAddress)"},{"location":"core/DaoRegistry/#function-processproposalbytes32-proposalid","text":"Marks an existing proposal as processed. Checks that the proposal has not been processed already and that it exists.","title":"function processProposal(bytes32 proposalId)"},{"location":"core/DaoRegistry/#function-_setproposalflagbytes32-proposalid-proposalflag-flag","text":"Internal utility function to set a flag to a proposal. It checks that the proposal exists and that the flag has not been already set.","title":"function _setProposalFlag(bytes32 proposalId, ProposalFlag flag)"},{"location":"core/DaoRegistry/#function-ismemberaddress-addr-public-view-returns-bool","text":"Returns true if the address is the delegate key of an existing member","title":"function isMember(address addr) public view returns (bool)"},{"location":"core/DaoRegistry/#function-getproposalflagbytes32-proposalid-proposalflag-flag-returns-bool","text":"Helper function to get the flag value for a proposal.","title":"function getProposalFlag(bytes32 proposalId, ProposalFlag flag) returns (bool)"},{"location":"core/DaoRegistry/#function-getmemberflagaddress-memberaddress-memberflag-flag-returns-bool","text":"Helper function to get the flag value for a member.","title":"function getMemberFlag(address memberAddress, MemberFlag flag) returns (bool)"},{"location":"core/DaoRegistry/#function-getnbmembers-public-view-returns-uint256","text":"Returns how many members have been registered in the DAO.","title":"function getNbMembers() public view returns (uint256)"},{"location":"core/DaoRegistry/#function-getmemberaddressuint256-index-public-view-returns-address","text":"Gets an address at a certain index in the members list.","title":"function getMemberAddress(uint256 index) public view returns (address)"},{"location":"core/DaoRegistry/#function-updatedelegatekeyaddress-memberaddr-address-newdelegatekey","text":"Updates the delegate key of a certain member. It checks that the delegate key is not being used by another member and is not the address of an existing member. It also checks that the member exists. If all the checks pass, the delegate key is updated and a delegate key checkpoint is created.","title":"function updateDelegateKey(address memberAddr, address newDelegateKey)"},{"location":"core/DaoRegistry/#function-getaddressifdelegatedaddress-checkaddr","text":"Returns the member address if the address is used as a delegate key or the address itself if it is not.","title":"function getAddressIfDelegated(address checkAddr)"},{"location":"core/DaoRegistry/#function-getcurrentdelegatekeyaddress-memberaddr-returns-address","text":"Returns the current delegate key for a member address.","title":"function getCurrentDelegateKey(address memberAddr) returns (address)"},{"location":"core/DaoRegistry/#function-getpreviousdelegatekeyaddress-memberaddr-returns-address","text":"Returns the previous delegate key for a member address. It is used to prepare the checkpoint.","title":"function getPreviousDelegateKey(address memberAddr) returns (address)"},{"location":"core/DaoRegistry/#function-getpriordelegatekeyaddress-memberaddr-uint256-blocknumber-returns-address","text":"Returns the delegate key for a member at a certain block number. If none are found, the memberAddr is returned instead.","title":"function getPriorDelegateKey(address memberAddr, uint256 blockNumber) returns (address)"},{"location":"core/DaoRegistry/#function-_createnewdelegatecheckpoint-address-member-address-newdelegatekey-internal","text":"Writes a new checkpoint for a specific member.","title":"function _createNewDelegateCheckpoint( address member, address newDelegateKey) internal"},{"location":"extensions/Bank/","text":"Extension description and scope This extension manages the funds of the DAO. The funds can be ETH or any ERC-20 token. It also manages internal tokens such as units and loot (but could be anything else). On top of that, it implements balance checkpoints so it is possible to retrieve prior balance at a certain block number. The balance is managed for the member address (not the delegate key). availableTokens and availableInteralTokens , are tokens that have been whitelisted for use with the DAO. A token goes from tokens or internalTokens to availableTokens and availableInternalTokens respectively when the function registerPotentialNewToken or registerPotentialNewInternalToken is called. Extension state address[] public tokens List of all the external tokens that are whitelisted in the bank. address[] public internalTokens List of all the internal tokens that have been whitelisted / created. mapping(address => bool) public availableTokens Same as the list of tokens but accessible in a random way. mapping(address => bool) public availableInternalTokens; Same as the list of internal tokens but accessible in a random way. mapping(address => mapping(address => mapping(uint32 => Checkpoint))) public checkpoints Checkpoints for each token / member. mapping(address => mapping(address => uint32)) public numCheckpoints Checkpoint counts for each token / member. Functions description, assumptions, checks, dependencies, interactions and access control function initialize(DaoRegistry _dao, address creator) This function can be called only once and only by the creator of the DAO. It registers the internal token UNITS, and gives 1 unit to the creator. function withdraw(address payable account, address tokenAddr, uint256 amount) This function is only accessible if you have extension access WITHDRAW . The function subtracts from the account the amount and then transfers the actual tokens to the account address. function isInternalToken(address token) returns (bool) Returns true if the token address is a registered internal token. function isTokenAllowed(address token) returns (bool) Returns true if the token address is a registered external token. function setMaxExternalTokens(uint8 maxTokens) Sets the maximum number of external tokens managed by the Bank. It is possible to set that only if the Bank extension has not been initialized, otherwise it will fail. By default the extension can not handle more than 200 tokens - to prevent issues with block size limit. function registerPotentialNewToken(address token) Whitelists a token if it is not already the case. function registerPotentialNewInternalToken(address token) Whitelists an internal token if it is not already the case. function getToken(uint256 index) external view returns (address) Gets the token at index in tokens. function nbTokens() external view returns (uint256) Return the length of tokens. function getInternalToken(uint256 index) external view returns (address) Gets the internal token at index in internalTokens. function nbInternalTokens() external view returns (uint256) Return the length of internalTokens. function addToBalance( address member, address token, uint256 amount) Adds to the member balance the amount in token. This also updates the checkpoint for this member / token. function subtractFromBalance(address user, address token, uint256 amount) Subtracts from the member balance the amount in token. This also updates the checkpoint for this member / token. function internalTransfer( address from, address to, address token, uint256 amount) Subtracts from the from address and then adds to the to address the amount in token. This also updates the checkpoint for the addresses / token. function updateToken(address tokenAddr) This function updates the internal bank accounting by calling the balance of the bank at the given token address. If the real total is higher than the internal total, the internal total is updated and the difference is added to the guild bank. If the real total is lower than the internal total then we have two cases: If the difference is lower than the guild bank, the difference is subtracted from the guild bank and the total is updated. If the difference is higher than the guild bank, the guild bank balance is set to 0 and the total is updated to subtract only what has been subtracted from the guild bank. Usually, the second case should not happen. A proper ERC-20 should not remove tokens without a direct action from the bank extension (and we have no way to approve the token either). But it is possible that some ERC-20 tokens are dynamically changing the balance and we need to take that into account. If too many tokens are being removed from the bank by a third party, keeping it out of sync seems to make sense to avoid getting into very complex accounting and trying to figure out who should get slashed too. If the balance changes again, calling updateToken can fix the issue. function balanceOf(address account, address tokenAddr) returns (uint256) Returns the balance of a certain account for a certain token. function getPriorAmount(address account, address tokenAddr, uint256 blockNumber) returns (uint256) Returns the balance of a certain account for a certain token at a certain point in time (block number). function _createNewAmountCheckpoint(address member, address tokenAddr, uint256 amount) Internal function to create a new amount checkpoint (if a balance has been updated).","title":"Bank"},{"location":"extensions/Bank/#extension-description-and-scope","text":"This extension manages the funds of the DAO. The funds can be ETH or any ERC-20 token. It also manages internal tokens such as units and loot (but could be anything else). On top of that, it implements balance checkpoints so it is possible to retrieve prior balance at a certain block number. The balance is managed for the member address (not the delegate key). availableTokens and availableInteralTokens , are tokens that have been whitelisted for use with the DAO. A token goes from tokens or internalTokens to availableTokens and availableInternalTokens respectively when the function registerPotentialNewToken or registerPotentialNewInternalToken is called.","title":"Extension description and scope"},{"location":"extensions/Bank/#extension-state","text":"","title":"Extension state"},{"location":"extensions/Bank/#address-public-tokens","text":"List of all the external tokens that are whitelisted in the bank.","title":"address[] public tokens"},{"location":"extensions/Bank/#address-public-internaltokens","text":"List of all the internal tokens that have been whitelisted / created.","title":"address[] public internalTokens"},{"location":"extensions/Bank/#mappingaddress-bool-public-availabletokens","text":"Same as the list of tokens but accessible in a random way.","title":"mapping(address =&gt; bool) public availableTokens"},{"location":"extensions/Bank/#mappingaddress-bool-public-availableinternaltokens","text":"Same as the list of internal tokens but accessible in a random way.","title":"mapping(address =&gt; bool) public availableInternalTokens;"},{"location":"extensions/Bank/#mappingaddress-mappingaddress-mappinguint32-checkpoint-public-checkpoints","text":"Checkpoints for each token / member.","title":"mapping(address =&gt; mapping(address =&gt; mapping(uint32 =&gt; Checkpoint))) public checkpoints"},{"location":"extensions/Bank/#mappingaddress-mappingaddress-uint32-public-numcheckpoints","text":"Checkpoint counts for each token / member.","title":"mapping(address =&gt; mapping(address =&gt; uint32)) public numCheckpoints"},{"location":"extensions/Bank/#functions-description-assumptions-checks-dependencies-interactions-and-access-control","text":"","title":"Functions description, assumptions, checks, dependencies, interactions and access control"},{"location":"extensions/Bank/#function-initializedaoregistry-_dao-address-creator","text":"This function can be called only once and only by the creator of the DAO. It registers the internal token UNITS, and gives 1 unit to the creator.","title":"function initialize(DaoRegistry _dao, address creator)"},{"location":"extensions/Bank/#function-withdrawaddress-payable-account-address-tokenaddr-uint256-amount","text":"This function is only accessible if you have extension access WITHDRAW . The function subtracts from the account the amount and then transfers the actual tokens to the account address.","title":"function withdraw(address payable account, address tokenAddr, uint256 amount)"},{"location":"extensions/Bank/#function-isinternaltokenaddress-token-returns-bool","text":"Returns true if the token address is a registered internal token.","title":"function isInternalToken(address token) returns (bool)"},{"location":"extensions/Bank/#function-istokenallowedaddress-token-returns-bool","text":"Returns true if the token address is a registered external token.","title":"function isTokenAllowed(address token) returns (bool)"},{"location":"extensions/Bank/#function-setmaxexternaltokensuint8-maxtokens","text":"Sets the maximum number of external tokens managed by the Bank. It is possible to set that only if the Bank extension has not been initialized, otherwise it will fail. By default the extension can not handle more than 200 tokens - to prevent issues with block size limit.","title":"function setMaxExternalTokens(uint8 maxTokens)"},{"location":"extensions/Bank/#function-registerpotentialnewtokenaddress-token","text":"Whitelists a token if it is not already the case.","title":"function registerPotentialNewToken(address token)"},{"location":"extensions/Bank/#function-registerpotentialnewinternaltokenaddress-token","text":"Whitelists an internal token if it is not already the case.","title":"function registerPotentialNewInternalToken(address token)"},{"location":"extensions/Bank/#function-gettokenuint256-index-external-view-returns-address","text":"Gets the token at index in tokens.","title":"function getToken(uint256 index) external view returns (address)"},{"location":"extensions/Bank/#function-nbtokens-external-view-returns-uint256","text":"Return the length of tokens.","title":"function nbTokens() external view returns (uint256)"},{"location":"extensions/Bank/#function-getinternaltokenuint256-index-external-view-returns-address","text":"Gets the internal token at index in internalTokens.","title":"function getInternalToken(uint256 index) external view returns (address)"},{"location":"extensions/Bank/#function-nbinternaltokens-external-view-returns-uint256","text":"Return the length of internalTokens.","title":"function nbInternalTokens() external view returns (uint256)"},{"location":"extensions/Bank/#function-addtobalance-address-member-address-token-uint256-amount","text":"Adds to the member balance the amount in token. This also updates the checkpoint for this member / token.","title":"function addToBalance( address member, address token, uint256 amount)"},{"location":"extensions/Bank/#function-subtractfrombalanceaddress-user-address-token-uint256-amount","text":"Subtracts from the member balance the amount in token. This also updates the checkpoint for this member / token.","title":"function subtractFromBalance(address user, address token, uint256 amount)"},{"location":"extensions/Bank/#function-internaltransfer-address-from-address-to-address-token-uint256-amount","text":"Subtracts from the from address and then adds to the to address the amount in token. This also updates the checkpoint for the addresses / token.","title":"function internalTransfer( address from, address to, address token, uint256 amount)"},{"location":"extensions/Bank/#function-updatetokenaddress-tokenaddr","text":"This function updates the internal bank accounting by calling the balance of the bank at the given token address. If the real total is higher than the internal total, the internal total is updated and the difference is added to the guild bank. If the real total is lower than the internal total then we have two cases: If the difference is lower than the guild bank, the difference is subtracted from the guild bank and the total is updated. If the difference is higher than the guild bank, the guild bank balance is set to 0 and the total is updated to subtract only what has been subtracted from the guild bank. Usually, the second case should not happen. A proper ERC-20 should not remove tokens without a direct action from the bank extension (and we have no way to approve the token either). But it is possible that some ERC-20 tokens are dynamically changing the balance and we need to take that into account. If too many tokens are being removed from the bank by a third party, keeping it out of sync seems to make sense to avoid getting into very complex accounting and trying to figure out who should get slashed too. If the balance changes again, calling updateToken can fix the issue.","title":"function updateToken(address tokenAddr)"},{"location":"extensions/Bank/#function-balanceofaddress-account-address-tokenaddr-returns-uint256","text":"Returns the balance of a certain account for a certain token.","title":"function balanceOf(address account, address tokenAddr) returns (uint256)"},{"location":"extensions/Bank/#function-getprioramountaddress-account-address-tokenaddr-uint256-blocknumber-returns-uint256","text":"Returns the balance of a certain account for a certain token at a certain point in time (block number).","title":"function getPriorAmount(address account, address tokenAddr, uint256 blockNumber) returns (uint256)"},{"location":"extensions/Bank/#function-_createnewamountcheckpointaddress-member-address-tokenaddr-uint256-amount","text":"Internal function to create a new amount checkpoint (if a balance has been updated).","title":"function _createNewAmountCheckpoint(address member, address tokenAddr, uint256 amount)"},{"location":"extensions/ERC20/","text":"Extension description and scope An ERC20 contract safely manages the transfers of tokens that represent the voting power of each member of the DAO. The extension adds to the DAO the capability of managing the voting power of members and external individuals in the DAO. It does that by tracking the token transfers between DAO members, or even, transfer from members to external accounts. That enhances the DAO features by allowing individuals that are not part of the DAO receive voting rights. Extension state DaoRegistry public dao; The DAO address that this extension belongs to bytes32 public constant ERC20_EXT_TRANSFER_TYPE = keccak256(\"erc20ExtTransferType\"); The custom configuration to set the transfer type, e.g: 0: transfers are enabled only between dao members 1: transfers are enabled between dao members and external accounts 2: all transfers are paused It needs to be set via a Configuration proposal , if the proposal pass, the new configuration gets stored in the DAO. By default, only transfers between members are allowed. bool public initialized = false; Internally tracks deployment under eip-1167 proxy pattern address public tokenAddress; The token address managed by the DAO that tracks the internal transfers string public tokenName; The name of the token managed by the DAO string public tokenSymbol; The symbol of the token managed by the DAO uint8 public tokenDecimals; The number of decimals of the token managed by the DAO. The default number of decimals is 0 in utils/DeploymentUtils.js. It is set to 0, because then the number of Units issued by the Bank Extension is tracked on a 1:1 basis with the number of tokens. For example, in the DAO issues 1 Unit to a member, then the display in a wallet such as MetaMask will be equal \"1\" Token. Otherwise, if the default was to the standard 18 decimals, then it would display in MetaMask as \"0.000000000000000001\" Token. mapping(address => mapping(address => uint256)) private _allowances; Tracks all the token allowances: owner => spender => amount Access Flags Bank : INTERNAL_TRANSFER: true : DAO : NEW_MEMBER: true Access Control Layer Flags - explicitly grant the extension permissions to change the bank and dao states. Extension functions function initialize /** * @notice Initializes the extension with the DAO that it belongs to, * and checks if the parameters were set. * @param _dao The address of the DAO that owns the extension. * @param creator The owner of the DAO and Extension that is also a member of the DAO. */ function initialize(DaoRegistry _dao, address creator) external override function token /** * @dev Returns the token address managed by the DAO that tracks the * internal transfers. */ function token() public view virtual returns (address) function setToken /** * @dev Sets the token address if the extension is not initialized, * not reserved and not zero. */ function setToken(address _tokenAddress) external function name /** * @dev Returns the name of the token. */ function name() public view virtual returns (string memory) function setName /** * @dev Sets the name of the token if the extension is not initialized. */ function setName(string memory _name) external function symbol /** * @dev Returns the symbol of the token, usually a shorter version of the * name. */ function symbol() public view virtual returns (string memory) function setSymbol /** * @dev Sets the token symbol if the extension is not initialized. */ function setSymbol(string memory _symbol) external function decimals /** * @dev Returns the number of decimals used to get its user representation. * For example, if `decimals` equals `2`, a balance of `505` tokens should * be displayed to a user as `5,05` (`505 / 10 ** 2`). */ function decimals() public view virtual returns (uint8) function setDecimals /** * @dev Sets the token decimals if the extension is not initialized. */ function setDecimals(uint8 _decimals) external function totalSupply /** * @dev Returns the amount of tokens in existence. */ function totalSupply() public view override returns (uint256) function balanceOf /** * @dev Returns the amount of tokens owned by `account`. */ function balanceOf(address account) public view override returns (uint256) function allowance /** * @dev Returns the remaining number of tokens that `spender` will be * allowed to spend on behalf of `owner` through {transferFrom}. This is * zero by default. * * This value changes when {approve} or {transferFrom} are called. */ function allowance(address owner, address spender) public view override returns (uint256) function approve /** * @dev Sets `amount` as the allowance of `spender` over the caller's tokens. * @param spender The address account that will have the units decremented. * @param amount The amount to decrement from the spender account. * @return a boolean value indicating whether the operation succeeded. * * Emits an {Approval} event. */ function approve(address spender, uint256 amount) public override reentrancyGuard(dao) returns (bool) function transfer /** * @dev Moves `amount` tokens from the caller's account to `recipient`. * @dev The transfer operation follows the DAO configuration specified * by the ERC20_EXT_TRANSFER_TYPE property. * @param recipient The address account that will have the units incremented. * @param amount The amount to increment in the recipient account. * @return a boolean value indicating whether the operation succeeded. * * Emits a {Transfer} event. */ function transfer(address recipient, uint256 amount) public override reentrancyGuard(dao) returns (bool) function transferFrom /** * @dev Moves `amount` tokens from `sender` to `recipient` using the * allowance mechanism. `amount` is then deducted from the caller's * allowance. * @dev The transfer operation follows the DAO configuration specified * by the ERC20_EXT_TRANSFER_TYPE property. * @param sender The address account that will have the units decremented. * @param recipient The address account that will have the units incremented. * @param amount The amount to decrement from the sender account. * @return a boolean value indicating whether the operation succeeded. * * Emits a {Transfer} event. */ function transferFrom( address sender, address recipient, uint256 amount ) public override reentrancyGuard(dao) returns (bool) Events Approval : when the sender approves a spender to transfer a certain amount. Transfer : when the transfer happens between DAO members and/or external accounts.","title":"ERC20"},{"location":"extensions/ERC20/#extension-description-and-scope","text":"An ERC20 contract safely manages the transfers of tokens that represent the voting power of each member of the DAO. The extension adds to the DAO the capability of managing the voting power of members and external individuals in the DAO. It does that by tracking the token transfers between DAO members, or even, transfer from members to external accounts. That enhances the DAO features by allowing individuals that are not part of the DAO receive voting rights.","title":"Extension description and scope"},{"location":"extensions/ERC20/#extension-state","text":"","title":"Extension state"},{"location":"extensions/ERC20/#daoregistry-public-dao","text":"The DAO address that this extension belongs to","title":"DaoRegistry public dao;"},{"location":"extensions/ERC20/#bytes32-public-constant-erc20_ext_transfer_type-keccak256erc20exttransfertype","text":"The custom configuration to set the transfer type, e.g: 0: transfers are enabled only between dao members 1: transfers are enabled between dao members and external accounts 2: all transfers are paused It needs to be set via a Configuration proposal , if the proposal pass, the new configuration gets stored in the DAO. By default, only transfers between members are allowed.","title":"bytes32 public constant ERC20_EXT_TRANSFER_TYPE = keccak256(\"erc20ExtTransferType\");"},{"location":"extensions/ERC20/#bool-public-initialized-false","text":"Internally tracks deployment under eip-1167 proxy pattern","title":"bool public initialized = false;"},{"location":"extensions/ERC20/#address-public-tokenaddress","text":"The token address managed by the DAO that tracks the internal transfers","title":"address public tokenAddress;"},{"location":"extensions/ERC20/#string-public-tokenname","text":"The name of the token managed by the DAO","title":"string public tokenName;"},{"location":"extensions/ERC20/#string-public-tokensymbol","text":"The symbol of the token managed by the DAO","title":"string public tokenSymbol;"},{"location":"extensions/ERC20/#uint8-public-tokendecimals","text":"The number of decimals of the token managed by the DAO. The default number of decimals is 0 in utils/DeploymentUtils.js. It is set to 0, because then the number of Units issued by the Bank Extension is tracked on a 1:1 basis with the number of tokens. For example, in the DAO issues 1 Unit to a member, then the display in a wallet such as MetaMask will be equal \"1\" Token. Otherwise, if the default was to the standard 18 decimals, then it would display in MetaMask as \"0.000000000000000001\" Token.","title":"uint8 public tokenDecimals;"},{"location":"extensions/ERC20/#mappingaddress-mappingaddress-uint256-private-_allowances","text":"Tracks all the token allowances: owner => spender => amount","title":"mapping(address =&gt; mapping(address =&gt; uint256)) private _allowances;"},{"location":"extensions/ERC20/#access-flags","text":"Bank : INTERNAL_TRANSFER: true : DAO : NEW_MEMBER: true Access Control Layer Flags - explicitly grant the extension permissions to change the bank and dao states.","title":"Access Flags"},{"location":"extensions/ERC20/#extension-functions","text":"","title":"Extension functions"},{"location":"extensions/ERC20/#function-initialize","text":"/** * @notice Initializes the extension with the DAO that it belongs to, * and checks if the parameters were set. * @param _dao The address of the DAO that owns the extension. * @param creator The owner of the DAO and Extension that is also a member of the DAO. */ function initialize(DaoRegistry _dao, address creator) external override","title":"function initialize"},{"location":"extensions/ERC20/#function-token","text":"/** * @dev Returns the token address managed by the DAO that tracks the * internal transfers. */ function token() public view virtual returns (address)","title":"function token"},{"location":"extensions/ERC20/#function-settoken","text":"/** * @dev Sets the token address if the extension is not initialized, * not reserved and not zero. */ function setToken(address _tokenAddress) external","title":"function setToken"},{"location":"extensions/ERC20/#function-name","text":"/** * @dev Returns the name of the token. */ function name() public view virtual returns (string memory)","title":"function name"},{"location":"extensions/ERC20/#function-setname","text":"/** * @dev Sets the name of the token if the extension is not initialized. */ function setName(string memory _name) external","title":"function setName"},{"location":"extensions/ERC20/#function-symbol","text":"/** * @dev Returns the symbol of the token, usually a shorter version of the * name. */ function symbol() public view virtual returns (string memory)","title":"function symbol"},{"location":"extensions/ERC20/#function-setsymbol","text":"/** * @dev Sets the token symbol if the extension is not initialized. */ function setSymbol(string memory _symbol) external","title":"function setSymbol"},{"location":"extensions/ERC20/#function-decimals","text":"/** * @dev Returns the number of decimals used to get its user representation. * For example, if `decimals` equals `2`, a balance of `505` tokens should * be displayed to a user as `5,05` (`505 / 10 ** 2`). */ function decimals() public view virtual returns (uint8)","title":"function decimals"},{"location":"extensions/ERC20/#function-setdecimals","text":"/** * @dev Sets the token decimals if the extension is not initialized. */ function setDecimals(uint8 _decimals) external","title":"function setDecimals"},{"location":"extensions/ERC20/#function-totalsupply","text":"/** * @dev Returns the amount of tokens in existence. */ function totalSupply() public view override returns (uint256)","title":"function totalSupply"},{"location":"extensions/ERC20/#function-balanceof","text":"/** * @dev Returns the amount of tokens owned by `account`. */ function balanceOf(address account) public view override returns (uint256)","title":"function balanceOf"},{"location":"extensions/ERC20/#function-allowance","text":"/** * @dev Returns the remaining number of tokens that `spender` will be * allowed to spend on behalf of `owner` through {transferFrom}. This is * zero by default. * * This value changes when {approve} or {transferFrom} are called. */ function allowance(address owner, address spender) public view override returns (uint256)","title":"function allowance"},{"location":"extensions/ERC20/#function-approve","text":"/** * @dev Sets `amount` as the allowance of `spender` over the caller's tokens. * @param spender The address account that will have the units decremented. * @param amount The amount to decrement from the spender account. * @return a boolean value indicating whether the operation succeeded. * * Emits an {Approval} event. */ function approve(address spender, uint256 amount) public override reentrancyGuard(dao) returns (bool)","title":"function approve"},{"location":"extensions/ERC20/#function-transfer","text":"/** * @dev Moves `amount` tokens from the caller's account to `recipient`. * @dev The transfer operation follows the DAO configuration specified * by the ERC20_EXT_TRANSFER_TYPE property. * @param recipient The address account that will have the units incremented. * @param amount The amount to increment in the recipient account. * @return a boolean value indicating whether the operation succeeded. * * Emits a {Transfer} event. */ function transfer(address recipient, uint256 amount) public override reentrancyGuard(dao) returns (bool)","title":"function transfer"},{"location":"extensions/ERC20/#function-transferfrom","text":"/** * @dev Moves `amount` tokens from `sender` to `recipient` using the * allowance mechanism. `amount` is then deducted from the caller's * allowance. * @dev The transfer operation follows the DAO configuration specified * by the ERC20_EXT_TRANSFER_TYPE property. * @param sender The address account that will have the units decremented. * @param recipient The address account that will have the units incremented. * @param amount The amount to decrement from the sender account. * @return a boolean value indicating whether the operation succeeded. * * Emits a {Transfer} event. */ function transferFrom( address sender, address recipient, uint256 amount ) public override reentrancyGuard(dao) returns (bool)","title":"function transferFrom"},{"location":"extensions/ERC20/#events","text":"Approval : when the sender approves a spender to transfer a certain amount. Transfer : when the transfer happens between DAO members and/or external accounts.","title":"Events"},{"location":"extensions/Executor/","text":"Extension description and scope The Executor Extension is a Proxy Contract inspired by the OpenZeppelin Proxy from OpenZeppelin team. The common use case for Proxy Patterns in Ethereum Blockchain is to make your contracts upgradable. This is achieved by setting up a proxy contract that allows you to call a new deployed contract as if the main logic has been upgraded. The trick here is to send the call through a Proxy contract, and use the delegatecall EVM instruction to redirect/delegate its the execution to the latest deployed contract logic. When working with Proxy contract we need to take into account: If you call a function that is not supported/implemented by the contract, the contract fallback function is trigged. You can customize your fallback function to handle special cases. For instance, you can make your proxy contract to use a custom fallback function to redirect/delegate calls to other contracts. If a contract A delegates a call to another contract B , A executes the code of contract B in the context of contract A , so the msg.value and msg.sender values will be preserved, i.e: you will not see the address of A as msg.sender in the executed function in B , but you will see the actual caller address that triggered the call to contract A . In addition to that, the storage modifications will always be applied to the storage of contract A , and B storage remains intact even after the delegated execution. With that in mind, we implemented the Executor Extension, which adds to the DAO the capability of executing delegated calls to another contract using the same EVM instruction delegatecall . The call is triggered via custom fallback function, which sets the msg.sender as the called address, and executes in the target contract identified by its address provided via implementation argument. For that, we can use the fallback function to pass the implementation address as the msg.sender , i.e: the contract A , in our example, will be calling itself through a proxy. This enables different use cases for proxy patterns in the Tribute DAO Framework. Most of the time, we determine who is calling a function by checking the msg.sender , but supposing we want to execute calls from the DAO through different adapters directly, msg.sender would be the address of the adapter itself, and that is an issue because an adapter can be shared between different DAOs. In addition to that, if you want to do execute a new logic from a new adapter, the adapter address would change, hence the msg.sender , and there is no way to link between them. However, when you execute the function call through the Executor Extension, suddenly the DAO has creates an identity, because the interaction with the implementation contract that triggers a new function call that will be using the msg.sender as the Executor address via an internal transaction, and that provides a generic proxy pattern that allows you to interact with other smart contracts with the same msg.sender (Executor Extension), no matter the logic implemented in the target contract. There are some restrictions and conventions that need to be respected to make sure the calls are executed safelly: The caller contract, usually an Adapter, must have permission to use the extension. The permission is set through the ACL Flag: EXECUTOR during the Adapter configuration phase. The caller contract must implement the function that will be triggered by the Executor, and it needs to be restricted to the Executor address only. It can be done by adding the access guard: executorFunc(dao) from AdapterGuard . The caller contract can not change/upgrade it's own state/storage in the logic function (i.e: the function that will be called by the Executor). The reason for that is to prevent storage collisions with the Executor storage. Any state change must be stored in a third contract, the contract that actually manages the state changes, and that will be associated to the Executor address though an internal transaction. With the Executor Extension we can cover new use cases, and basically execute any sort function call from the DAO to the outside world. Considering the Tribute DAO Framework architecture, the call should always go through an Adapter, because a core contract should not acess the extenal world directly, but it is fine if it relies on an Adapter. Some examples of these proxy call are: joining an LP from the DAO (with staking). joining another DAO. claiming money from a parent DAO. Extension state DaoRegistry public dao; The DAO address that this extension belongs to bool public initialized = false; Internally tracks deployment under eip-1167 proxy pattern Access Flags None, it does not access the DAO Registry. Access Control Layer Flags - explicitly grant the extension permissions to change the bank and dao states. Extension functions function initialize /** * @notice Initializes the extension with the DAO that it belongs to, * and checks if the parameters were set. * @param _dao The address of the DAO that owns the extension. * @param creator The owner of the DAO and Extension that is also a member of the DAO. */ function initialize(DaoRegistry _dao, address creator) external override function _delegate /** * @dev Delegates the current call to `implementation`. * * This function does not return to its internall call site, it will return directly to the external caller. */ function _delegate(address implementation) internal virtual hasExtensionAccess(AclFlag.EXECUTE) function _fallback /** * @dev Delegates the current call to the sender address. * * This function does not return to its internall call site, it will return directly to the external caller. */ function _fallback() internal virtual function fallback /** * @dev Fallback function that delegates calls to the sender address. Will run if no other * function in the contract matches the call data. */ fallback() external payable function receive /** * @dev Fallback function that delegates calls to the address returned by `_implementation()`. */ receive() external payable Events No events are emitted. Required Access Permissions EXECUTE : to be able to execute the delegatedcall using the Executor Proxy pattern.","title":"Executor"},{"location":"extensions/Executor/#extension-description-and-scope","text":"The Executor Extension is a Proxy Contract inspired by the OpenZeppelin Proxy from OpenZeppelin team. The common use case for Proxy Patterns in Ethereum Blockchain is to make your contracts upgradable. This is achieved by setting up a proxy contract that allows you to call a new deployed contract as if the main logic has been upgraded. The trick here is to send the call through a Proxy contract, and use the delegatecall EVM instruction to redirect/delegate its the execution to the latest deployed contract logic. When working with Proxy contract we need to take into account: If you call a function that is not supported/implemented by the contract, the contract fallback function is trigged. You can customize your fallback function to handle special cases. For instance, you can make your proxy contract to use a custom fallback function to redirect/delegate calls to other contracts. If a contract A delegates a call to another contract B , A executes the code of contract B in the context of contract A , so the msg.value and msg.sender values will be preserved, i.e: you will not see the address of A as msg.sender in the executed function in B , but you will see the actual caller address that triggered the call to contract A . In addition to that, the storage modifications will always be applied to the storage of contract A , and B storage remains intact even after the delegated execution. With that in mind, we implemented the Executor Extension, which adds to the DAO the capability of executing delegated calls to another contract using the same EVM instruction delegatecall . The call is triggered via custom fallback function, which sets the msg.sender as the called address, and executes in the target contract identified by its address provided via implementation argument. For that, we can use the fallback function to pass the implementation address as the msg.sender , i.e: the contract A , in our example, will be calling itself through a proxy. This enables different use cases for proxy patterns in the Tribute DAO Framework. Most of the time, we determine who is calling a function by checking the msg.sender , but supposing we want to execute calls from the DAO through different adapters directly, msg.sender would be the address of the adapter itself, and that is an issue because an adapter can be shared between different DAOs. In addition to that, if you want to do execute a new logic from a new adapter, the adapter address would change, hence the msg.sender , and there is no way to link between them. However, when you execute the function call through the Executor Extension, suddenly the DAO has creates an identity, because the interaction with the implementation contract that triggers a new function call that will be using the msg.sender as the Executor address via an internal transaction, and that provides a generic proxy pattern that allows you to interact with other smart contracts with the same msg.sender (Executor Extension), no matter the logic implemented in the target contract. There are some restrictions and conventions that need to be respected to make sure the calls are executed safelly: The caller contract, usually an Adapter, must have permission to use the extension. The permission is set through the ACL Flag: EXECUTOR during the Adapter configuration phase. The caller contract must implement the function that will be triggered by the Executor, and it needs to be restricted to the Executor address only. It can be done by adding the access guard: executorFunc(dao) from AdapterGuard . The caller contract can not change/upgrade it's own state/storage in the logic function (i.e: the function that will be called by the Executor). The reason for that is to prevent storage collisions with the Executor storage. Any state change must be stored in a third contract, the contract that actually manages the state changes, and that will be associated to the Executor address though an internal transaction. With the Executor Extension we can cover new use cases, and basically execute any sort function call from the DAO to the outside world. Considering the Tribute DAO Framework architecture, the call should always go through an Adapter, because a core contract should not acess the extenal world directly, but it is fine if it relies on an Adapter. Some examples of these proxy call are: joining an LP from the DAO (with staking). joining another DAO. claiming money from a parent DAO.","title":"Extension description and scope"},{"location":"extensions/Executor/#extension-state","text":"","title":"Extension state"},{"location":"extensions/Executor/#daoregistry-public-dao","text":"The DAO address that this extension belongs to","title":"DaoRegistry public dao;"},{"location":"extensions/Executor/#bool-public-initialized-false","text":"Internally tracks deployment under eip-1167 proxy pattern","title":"bool public initialized = false;"},{"location":"extensions/Executor/#access-flags","text":"None, it does not access the DAO Registry. Access Control Layer Flags - explicitly grant the extension permissions to change the bank and dao states.","title":"Access Flags"},{"location":"extensions/Executor/#extension-functions","text":"","title":"Extension functions"},{"location":"extensions/Executor/#function-initialize","text":"/** * @notice Initializes the extension with the DAO that it belongs to, * and checks if the parameters were set. * @param _dao The address of the DAO that owns the extension. * @param creator The owner of the DAO and Extension that is also a member of the DAO. */ function initialize(DaoRegistry _dao, address creator) external override","title":"function initialize"},{"location":"extensions/Executor/#function-_delegate","text":"/** * @dev Delegates the current call to `implementation`. * * This function does not return to its internall call site, it will return directly to the external caller. */ function _delegate(address implementation) internal virtual hasExtensionAccess(AclFlag.EXECUTE)","title":"function _delegate"},{"location":"extensions/Executor/#function-_fallback","text":"/** * @dev Delegates the current call to the sender address. * * This function does not return to its internall call site, it will return directly to the external caller. */ function _fallback() internal virtual","title":"function _fallback"},{"location":"extensions/Executor/#function-fallback","text":"/** * @dev Fallback function that delegates calls to the sender address. Will run if no other * function in the contract matches the call data. */ fallback() external payable","title":"function fallback"},{"location":"extensions/Executor/#function-receive","text":"/** * @dev Fallback function that delegates calls to the address returned by `_implementation()`. */ receive() external payable","title":"function receive"},{"location":"extensions/Executor/#events","text":"No events are emitted.","title":"Events"},{"location":"extensions/Executor/#required-access-permissions","text":"EXECUTE : to be able to execute the delegatedcall using the Executor Proxy pattern.","title":"Required Access Permissions"},{"location":"extensions/NFT/","text":"Extension description and scope An IERC721Receiver contract safely manages the collection of standard NFTs (ERC721) collected by the DAO. The extension adds to the DAO the capability of managing and curating a collection of standard NFTs. Applicants can join the DAO offering NFTs as tributes, and if their proposal is approved their tributes get stored in the guild NFT collection - which supports tokens in ERC721 standard. In order to join the DAO using a NFT as tribute, the DAO must have the TributeNFT Adapter pre-configured with the correct Access Flags . Extension state bool public initialized = false; Internally tracks deployment under eip-1167 proxy pattern. DaoRegistry public dao; Keeps track of each DAO instance the current contract belongs to. Access Flags COLLECT_NFT : Allows the caller adapter to transfer the NFT to the GUILD collection. WITHDRAW_NFT : Allows the caller to remove the NFT from the GUILD collection and return it to a new owner. INTERNAL_TRANSFER : Allows the caller to update the internal ownership of the NFT within the GUILD collection. Access Control Layer Flags - explicitly grant external call permissions to change the extension state. mapping(address => EnumerableSet.UintSet) private _nfts; Tracks all the Token IDs that belong to an NFT address stored in the GUILD collection. mapping(bytes32 => address) private _ownership; Tracks the internal owner of record of an NFT that has been transferred to the extension. EnumerableSet.AddressSet private _nftAddresses; Tracks all the NFTs addresses collected and stored in the GUILD collection. Extension functions function initialize /** * @notice Initializes the extension with the DAO address that it belongs to. * @param _dao The address of the DAO that owns the extension. * @param creator The owner of the DAO and Extension that is also a member of the DAO. */ function initialize(DaoRegistry _dao, address creator) external function collect /** * @notice Collects the NFT from the owner and moves it to the NFT extension. * @notice It must be have been allowed to move this token by either {approve} or {setApprovalForAll}. * @notice The caller must have the ACL Flag: COLLECT_NFT * @dev Reverts if the NFT is not in ERC721 standard. * @param nftAddr The NFT contract address. * @param nftTokenId The NFT token id. */ function collect( address nftAddr, uint256 nftTokenId ) external function withdrawNFT /** * @notice Ttransfers the NFT token from the extension address to the new owner. * @notice It also updates the internal state to keep track of the all the NFTs collected by the extension. * @notice The caller must have the ACL Flag: WITHDRAW_NFT * @dev Reverts if the NFT is not in ERC721 standard. * @param newOwner The address of the new owner. * @param nftAddr The NFT address that must be in ERC721 standard. * @param nftTokenId The NFT token id. */ function withdrawNFT( address newOwner, address nftAddr, uint256 nftTokenId ) public hasExtensionAccess(this, AclFlag.WITHDRAW_NFT) function internalTransfer /** * @notice Updates internally the ownership of the NFT. * @notice The caller must have the ACL Flag: INTERNAL_TRANSFER * @dev Reverts if the NFT is not already internally owned in the extension. * @param nftAddr The NFT address. * @param nftTokenId The NFT token id. * @param newOwner The address of the new owner. */ function transferFrom( address escrowAddr, address nftAddr, address newOwner ) public hasExtensionAccess(this, AclFlag.INTERNAL_TRANSFER) function getNFTId /** * @notice Gets ID generated from an NFT address and token id (used internally to map ownership). * @param nftAddress The NFT address. * @param tokenId The NFT token id. */ function getNFTId(address nftAddress, uint256 tokenId) public pure returns (bytes32) function nbNFTs /** * @notice Returns the total amount of token ids collected for an NFT address. */ function nbNFTs(address tokenAddr) public view returns (uint256) function getNFT /** * @notice Returns token id associated with an NFT address stored in the GUILD collection at the specified index. * @param tokenAddr The NFT address. * @param index The index to get the token id if it exists. */ function getNFT(address tokenAddr, uint256 index) public view returns (uint256) function nbNFTAddresses /** * @notice Returns the total amount of NFT addresses collected. */ function nbNFTAddresses() external view returns (uint256) function getNFTAddress /** * @notice Returns NFT address stored in the GUILD collection at the specified index. * @param index The index to get the NFT address if it exists. */ function getNFTAddress(uint256 index) external view returns (address) function getNFTOwner /** * @notice Returns owner of NFT that has been transferred to the extension. * @param nftAddress The NFT address. * @param tokenId The NFT token id. */ function getNFTOwner(address nftAddress, uint256 tokenId) public view returns (address) function onERC721Received /** * @notice Required function from IERC721 standard to be able to receive assets to this contract address. */ function onERC721Received( address, address, uint256, bytes calldata ) external pure override returns (bytes4) function _saveNft /** * @notice Helper function to update the extension states for an NFT collected by the extension. * @param nftAddr The NFT address. * @param nftTokenId The token id. * @param owner The address of the owner. */ function _saveNft( address nftAddr, uint256 nftTokenId, address owner ) private Events CollectedNFT : when a NFT is collected/stored into the NFT collection. WithdrawnNFT : when a NFT is transferred from the extension to another owner. TransferredNFT : when a NFT is transferred from the escrow adapter to the NFT collection in the extension.","title":"NFT"},{"location":"extensions/NFT/#extension-description-and-scope","text":"An IERC721Receiver contract safely manages the collection of standard NFTs (ERC721) collected by the DAO. The extension adds to the DAO the capability of managing and curating a collection of standard NFTs. Applicants can join the DAO offering NFTs as tributes, and if their proposal is approved their tributes get stored in the guild NFT collection - which supports tokens in ERC721 standard. In order to join the DAO using a NFT as tribute, the DAO must have the TributeNFT Adapter pre-configured with the correct Access Flags .","title":"Extension description and scope"},{"location":"extensions/NFT/#extension-state","text":"","title":"Extension state"},{"location":"extensions/NFT/#bool-public-initialized-false","text":"Internally tracks deployment under eip-1167 proxy pattern.","title":"bool public initialized = false;"},{"location":"extensions/NFT/#daoregistry-public-dao","text":"Keeps track of each DAO instance the current contract belongs to.","title":"DaoRegistry public dao;"},{"location":"extensions/NFT/#access-flags","text":"COLLECT_NFT : Allows the caller adapter to transfer the NFT to the GUILD collection. WITHDRAW_NFT : Allows the caller to remove the NFT from the GUILD collection and return it to a new owner. INTERNAL_TRANSFER : Allows the caller to update the internal ownership of the NFT within the GUILD collection. Access Control Layer Flags - explicitly grant external call permissions to change the extension state.","title":"Access Flags"},{"location":"extensions/NFT/#mappingaddress-enumerablesetuintset-private-_nfts","text":"Tracks all the Token IDs that belong to an NFT address stored in the GUILD collection.","title":"mapping(address =&gt; EnumerableSet.UintSet) private _nfts;"},{"location":"extensions/NFT/#mappingbytes32-address-private-_ownership","text":"Tracks the internal owner of record of an NFT that has been transferred to the extension.","title":"mapping(bytes32 =&gt; address) private _ownership;"},{"location":"extensions/NFT/#enumerablesetaddressset-private-_nftaddresses","text":"Tracks all the NFTs addresses collected and stored in the GUILD collection.","title":"EnumerableSet.AddressSet private _nftAddresses;"},{"location":"extensions/NFT/#extension-functions","text":"","title":"Extension functions"},{"location":"extensions/NFT/#function-initialize","text":"/** * @notice Initializes the extension with the DAO address that it belongs to. * @param _dao The address of the DAO that owns the extension. * @param creator The owner of the DAO and Extension that is also a member of the DAO. */ function initialize(DaoRegistry _dao, address creator) external","title":"function initialize"},{"location":"extensions/NFT/#function-collect","text":"/** * @notice Collects the NFT from the owner and moves it to the NFT extension. * @notice It must be have been allowed to move this token by either {approve} or {setApprovalForAll}. * @notice The caller must have the ACL Flag: COLLECT_NFT * @dev Reverts if the NFT is not in ERC721 standard. * @param nftAddr The NFT contract address. * @param nftTokenId The NFT token id. */ function collect( address nftAddr, uint256 nftTokenId ) external","title":"function collect"},{"location":"extensions/NFT/#function-withdrawnft","text":"/** * @notice Ttransfers the NFT token from the extension address to the new owner. * @notice It also updates the internal state to keep track of the all the NFTs collected by the extension. * @notice The caller must have the ACL Flag: WITHDRAW_NFT * @dev Reverts if the NFT is not in ERC721 standard. * @param newOwner The address of the new owner. * @param nftAddr The NFT address that must be in ERC721 standard. * @param nftTokenId The NFT token id. */ function withdrawNFT( address newOwner, address nftAddr, uint256 nftTokenId ) public hasExtensionAccess(this, AclFlag.WITHDRAW_NFT)","title":"function withdrawNFT"},{"location":"extensions/NFT/#function-internaltransfer","text":"/** * @notice Updates internally the ownership of the NFT. * @notice The caller must have the ACL Flag: INTERNAL_TRANSFER * @dev Reverts if the NFT is not already internally owned in the extension. * @param nftAddr The NFT address. * @param nftTokenId The NFT token id. * @param newOwner The address of the new owner. */ function transferFrom( address escrowAddr, address nftAddr, address newOwner ) public hasExtensionAccess(this, AclFlag.INTERNAL_TRANSFER)","title":"function internalTransfer"},{"location":"extensions/NFT/#function-getnftid","text":"/** * @notice Gets ID generated from an NFT address and token id (used internally to map ownership). * @param nftAddress The NFT address. * @param tokenId The NFT token id. */ function getNFTId(address nftAddress, uint256 tokenId) public pure returns (bytes32)","title":"function getNFTId"},{"location":"extensions/NFT/#function-nbnfts","text":"/** * @notice Returns the total amount of token ids collected for an NFT address. */ function nbNFTs(address tokenAddr) public view returns (uint256)","title":"function nbNFTs"},{"location":"extensions/NFT/#function-getnft","text":"/** * @notice Returns token id associated with an NFT address stored in the GUILD collection at the specified index. * @param tokenAddr The NFT address. * @param index The index to get the token id if it exists. */ function getNFT(address tokenAddr, uint256 index) public view returns (uint256)","title":"function getNFT"},{"location":"extensions/NFT/#function-nbnftaddresses","text":"/** * @notice Returns the total amount of NFT addresses collected. */ function nbNFTAddresses() external view returns (uint256)","title":"function nbNFTAddresses"},{"location":"extensions/NFT/#function-getnftaddress","text":"/** * @notice Returns NFT address stored in the GUILD collection at the specified index. * @param index The index to get the NFT address if it exists. */ function getNFTAddress(uint256 index) external view returns (address)","title":"function getNFTAddress"},{"location":"extensions/NFT/#function-getnftowner","text":"/** * @notice Returns owner of NFT that has been transferred to the extension. * @param nftAddress The NFT address. * @param tokenId The NFT token id. */ function getNFTOwner(address nftAddress, uint256 tokenId) public view returns (address)","title":"function getNFTOwner"},{"location":"extensions/NFT/#function-onerc721received","text":"/** * @notice Required function from IERC721 standard to be able to receive assets to this contract address. */ function onERC721Received( address, address, uint256, bytes calldata ) external pure override returns (bytes4)","title":"function onERC721Received"},{"location":"extensions/NFT/#function-_savenft","text":"/** * @notice Helper function to update the extension states for an NFT collected by the extension. * @param nftAddr The NFT address. * @param nftTokenId The token id. * @param owner The address of the owner. */ function _saveNft( address nftAddr, uint256 nftTokenId, address owner ) private","title":"function _saveNft"},{"location":"extensions/NFT/#events","text":"CollectedNFT : when a NFT is collected/stored into the NFT collection. WithdrawnNFT : when a NFT is transferred from the extension to another owner. TransferredNFT : when a NFT is transferred from the escrow adapter to the NFT collection in the extension.","title":"Events"},{"location":"guards/AdapterGuard/","text":"AdapterGuard.sol onlyAdapter(DaoRegistry dao) a modifier to ensure that only adapters registered to the DAO can execute the function call. hasAccess(DaoRegistry dao, FlagHelper.Flag flag) a modifier to monitor the state of whether an adapter in the DAO can access one of the core functions in DaoRegistry.sol .","title":"AdapterGuard"},{"location":"guards/AdapterGuard/#adapterguardsol","text":"onlyAdapter(DaoRegistry dao) a modifier to ensure that only adapters registered to the DAO can execute the function call. hasAccess(DaoRegistry dao, FlagHelper.Flag flag) a modifier to monitor the state of whether an adapter in the DAO can access one of the core functions in DaoRegistry.sol .","title":"AdapterGuard.sol"},{"location":"guards/MemberGuard/","text":"MemberGuard.sol onlyMember(DaoRegistry dao) Only members of the DAO are allowed to execute the function call.","title":"MemberGuard"},{"location":"guards/MemberGuard/#memberguardsol","text":"onlyMember(DaoRegistry dao) Only members of the DAO are allowed to execute the function call.","title":"MemberGuard.sol"},{"location":"helpers/FairShareHelper/","text":"FairShareHelper.sol a library with one function calc(balance, units, _totalUnits) to calculate the fair unit amount of tokens based the total units and current balance.\\","title":"FairShareHelper"},{"location":"helpers/FairShareHelper/#fairsharehelpersol","text":"a library with one function calc(balance, units, _totalUnits) to calculate the fair unit amount of tokens based the total units and current balance.\\","title":"FairShareHelper.sol"}]}