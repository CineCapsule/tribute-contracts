(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[5497],{3905:function(e,t,n){"use strict";n.d(t,{Zo:function(){return d},kt:function(){return h}});var a=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function r(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var c=a.createContext({}),l=function(e){var t=a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},d=function(e){var t=l(e.components);return a.createElement(c.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,i=e.originalType,c=e.parentName,d=r(e,["components","mdxType","originalType","parentName"]),u=l(n),h=o,m=u["".concat(c,".").concat(h)]||u[h]||p[h]||i;return n?a.createElement(m,s(s({ref:t},d),{},{components:n})):a.createElement(m,s({ref:t},d))}));function h(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var i=n.length,s=new Array(i);s[0]=u;var r={};for(var c in t)hasOwnProperty.call(t,c)&&(r[c]=t[c]);r.originalType=e,r.mdxType="string"==typeof e?e:o,s[1]=r;for(var l=2;l<i;l++)s[l]=n[l];return a.createElement.apply(null,s)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},1058:function(e,t,n){"use strict";n.r(t),n.d(t,{frontMatter:function(){return r},metadata:function(){return c},toc:function(){return l},default:function(){return p}});var a=n(2122),o=n(9756),i=(n(7294),n(3905)),s=["components"],r={id:"creating-an-extension",title:"How to create an Extension"},c={unversionedId:"tutorial/extensions/creating-an-extension",id:"tutorial/extensions/creating-an-extension",isDocsHomePage:!1,title:"How to create an Extension",description:"Extensions are reusable smart contracts that add additional capabilities to the DAO without cluttering the core contracts with complex logic.",source:"@site/docs/tutorial/extensions/HowToCreateAnExtension.md",sourceDirName:"tutorial/extensions",slug:"/tutorial/extensions/creating-an-extension",permalink:"/tribute-contracts/docs/tutorial/extensions/creating-an-extension",editUrl:"https://github.com/openlawteam/tribute-contracts/edit/docs/website/docs/tutorial/extensions/HowToCreateAnExtension.md",version:"current",frontMatter:{id:"creating-an-extension",title:"How to create an Extension"},sidebar:"docs",previous:{title:"How to create an Adapter",permalink:"/tribute-contracts/docs/tutorial/adapters/creating-an-adapter"}},l=[{value:"Defining the Interface",id:"defining-the-interface",children:[]},{value:"Map out the proper Access Flags",id:"map-out-the-proper-access-flags",children:[]},{value:"Set up the DAO custom configurations",id:"set-up-the-dao-custom-configurations",children:[]},{value:"Be mindful of the storage costs",id:"be-mindful-of-the-storage-costs",children:[]},{value:"Conventions &amp; Implementation",id:"conventions--implementation",children:[]},{value:"Testing the new Extension",id:"testing-the-new-extension",children:[]},{value:"Adding documentation",id:"adding-documentation",children:[]},{value:"Done",id:"done",children:[]}],d={toc:l};function p(e){var t=e.components,n=(0,o.Z)(e,s);return(0,i.kt)("wrapper",(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"/docs/intro/design/extensions/introduction"},"Extensions")," are reusable smart contracts that add additional capabilities to the DAO without cluttering the core contracts with complex logic."),(0,i.kt)("p",null,"The key different between an ",(0,i.kt)("strong",{parentName:"p"},(0,i.kt)("a",{parentName:"strong",href:"/docs/tutorial/adapters/creating-an-adapter"},"Adapter"))," and an ",(0,i.kt)("strong",{parentName:"p"},"Extension"),", is that adapters are not tied to a specific DAO address, so you can use the exact same Adapter to perform actions in different DAOs. While the ",(0,i.kt)("strong",{parentName:"p"},"Extensions")," are instantiate and associated to a particular DAO, because an extension can track additional state information of that DAO, and is used as an extension of the DAO core features. It means that a Core contract is allowed to execute calls to an Extension, but not to an Adapter."),(0,i.kt)("p",null,"Each extension needs to be configured with the DaoRegistry ",(0,i.kt)("strong",{parentName:"p"},(0,i.kt)("a",{parentName:"strong",href:"/docs/contracts/core/dao-registry#access-flags"},"Access Flags"))," in order to access the ",(0,i.kt)("strong",{parentName:"p"},(0,i.kt)("a",{parentName:"strong",href:"/docs/intro/design/core/introduction"},"Core Contracts")),", but it also can define its own Access Flags that will be required if an Adapter interacts with it."),(0,i.kt)("div",{className:"admonition admonition-tip alert alert--success"},(0,i.kt)("div",{parentName:"div",className:"admonition-heading"},(0,i.kt)("h5",{parentName:"div"},(0,i.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,i.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},(0,i.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"}))),"tip")),(0,i.kt)("div",{parentName:"div",className:"admonition-content"},(0,i.kt)("p",{parentName:"div"},"Extensions can defined their own Access Flags to retrict access to its functions. Any Adapter that needs to interact with the extension needs to configure the custom access flags."))),(0,i.kt)("h3",{id:"defining-the-interface"},"Defining the Interface"),(0,i.kt)("p",null,"The extension must implement the ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/openlawteam/tribute-contracts/blob/master/contracts/extensions/IExtension.sol"},"IExtension")," to be able to initialize the extension and set the correct DAO address that it belongs to."),(0,i.kt)("p",null,"It is a good practice to always verify if the extension was not initialized, and if the creator is a DAO member, otherwise the extension creation call might be hijacked."),(0,i.kt)("p",null,"If your extension will be used by adapters only, you can use the ",(0,i.kt)("inlineCode",{parentName:"p"},"AdapterGuard")," function ",(0,i.kt)("inlineCode",{parentName:"p"},"onlyAdapter")," to check if the adapter is registered in the DAO and is allowed to call your extension."),(0,i.kt)("p",null,"Here is a simple implementation that performs the verification:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-solidity"},'contract MyExtension is DaoConstants, IExtension {\n  // Internally tracks deployment under eip-1167 proxy pattern\n  bool public initialized = false;\n\n  // The DAO address that is the owner of this extension\n  DaoRegistry public dao;\n\n  /// @notice Clonable contract must have an empty constructor\n  // constructor() {\n  // }\n\n  /**\n   * @notice Initialises the extension to be associated with a DAO\n   * @dev Can only be called once\n   * @param creator The DAO\'s creator, who will be an initial member\n   */\n  function initialize(DaoRegistry _dao, address creator) external override {\n    require(!initialized, "executor::already initialized");\n    require(_dao.isMember(creator), "executor::not member");\n    dao = _dao;\n    initialized = true;\n  }\n}\n\n')),(0,i.kt)("div",{className:"admonition admonition-caution alert alert--warning"},(0,i.kt)("div",{parentName:"div",className:"admonition-heading"},(0,i.kt)("h5",{parentName:"div"},(0,i.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,i.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"16",height:"16",viewBox:"0 0 16 16"},(0,i.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M8.893 1.5c-.183-.31-.52-.5-.887-.5s-.703.19-.886.5L.138 13.499a.98.98 0 0 0 0 1.001c.193.31.53.501.886.501h13.964c.367 0 .704-.19.877-.5a1.03 1.03 0 0 0 .01-1.002L8.893 1.5zm.133 11.497H6.987v-2.003h2.039v2.003zm0-3.004H6.987V5.987h2.039v4.006z"}))),"caution")),(0,i.kt)("div",{parentName:"div",className:"admonition-content"},(0,i.kt)("p",{parentName:"div"},"Make sure you implement the initialization function to check if the creator belongs to the DAO, and if the extension was not initialized yet."))),(0,i.kt)("h3",{id:"map-out-the-proper-access-flags"},"Map out the proper Access Flags"),(0,i.kt)("p",null,"Another important point is to map out which sort of permissions your extension will require, so other client can set that up before using it."),(0,i.kt)("p",null,"In order to configure the access control layer in your extension, we use the same ",(0,i.kt)("strong",{parentName:"p"},(0,i.kt)("a",{parentName:"strong",href:"/docs/contracts/core/access-control"},"Access Flags"))," concept that we have in the Core contracts. For that we can define:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Which flags the extension will require."),(0,i.kt)("li",{parentName:"ol"},"The guard implementation that will verify if the caller is allowed to execute the call.")),(0,i.kt)("p",null,"Example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-solidity"},'\n  enum AclFlag { EXECUTE }\n\n  modifier hasExtensionAccess(AclFlag flag) {\n        require(\n            // 1. Allowed if the extension is calling itself\n               address(this) == msg.sender ||\n            // 2. Allowed if the DAO is calling the extension\n                address(dao) == msg.sender ||\n            // 3. Allowed if the DAO state is in CREATION mode\n                dao.state() == DaoRegistry.DaoState.CREATION ||\n            // 4. Allowed if the sender is a registered adapter\n                dao.hasAdapterAccessToExtension(\n                    msg.sender,\n                    address(this),\n                    uint8(flag)\n                ),\n            // 5. Revert message\n            "myExtension::accessDenied"\n        );\n        _;\n    }\n\n')),(0,i.kt)("p",null,"In the example above we want to allow the call execution in 4 different scenarios:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"The extension is calling itself:"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"useful if you have some sort of proxy pattern or delegate call."))),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"The DAO is calling the extension:"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"when the DAO needs to read/write info to the extension."))),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"The DAO state is in CREATION mode:"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"when the DAO is configuring the new extension during the ",(0,i.kt)("inlineCode",{parentName:"li"},"dao.addExtension")," call."))),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"The sender is a registered adapter:"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"an adapter uses the extension to read/write info.")))),(0,i.kt)("h3",{id:"set-up-the-dao-custom-configurations"},"Set up the DAO custom configurations"),(0,i.kt)("p",null,"In some cases extensions might need customized configurations to make decisions on the fly. These configurations can and should be set per DAO. In order to do that you have to identify which configuration parameters you need, and set them up through a proposal process via ",(0,i.kt)("strong",{parentName:"p"},(0,i.kt)("a",{parentName:"strong",href:"/docs/contracts/adapters/configuration/configuration-adapter"},"Configuration Adapter")),". You can find an example of the usage in the ",(0,i.kt)("strong",{parentName:"p"},(0,i.kt)("a",{parentName:"strong",href:"/docs/contracts/extensions/erc20-extension#transfer"},"ERC20 Extension")),"."),(0,i.kt)("p",null,"In order to access the configuration parameter in your extension you can simply call this function:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-solidity"},'\n  uint256 myConfig = dao.getConfiguration("myExtension.config.name");\n\n')),(0,i.kt)("h3",{id:"be-mindful-of-the-storage-costs"},"Be mindful of the storage costs"),(0,i.kt)("p",null,"The extension usually saves additional state that we don't want to propagate to the DAO Registry, however it is important to try to not use the storage that much. We prefer efficient and cheap extensions that can be easily deployable and maintainable. The less state it maintains and operations it executes, the better."),(0,i.kt)("h3",{id:"conventions--implementation"},"Conventions & Implementation"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Function names (public)"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"myFunctionX"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Function names (private)"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"_","myFunctionX"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Revert as early as possible")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Your extension should not accept any funds. So it is a good practice to always revert the receive call."),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-solidity"},'/**\n * @notice default fallback function to prevent from sending ether to the contract.\n */\nreceive() external payable {\n  revert("fallback revert");\n}\n\n'))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Make sure you add the correct ",(0,i.kt)("inlineCode",{parentName:"p"},"require")," checks"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Usually the extension needs to perform some verifications before executing the calls that may change the DAO state. Double check if the DAORegistry functions that your extension uses already implement some checks, so you do not need to repeat them in the adapter."))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Update the DAOConstants"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"If you are creating an extension that does not have the ",(0,i.kt)("inlineCode",{parentName:"li"},"keccak256")," id declared in the ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/openlawteam/tribute-contracts/blob/master/contracts/core/DaoConstants.sol#L45"},"DAOConstants")," make sure you add it there."))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Add the correct function guards"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"onlyAdapter"),(0,i.kt)("li",{parentName:"ul"},"hasExtensionAccess")))),(0,i.kt)("p",null,"After implemeting the functions that your extension will expose, and setting the correct guards, names, and conventions you should have, at this state, an extension code similar to the following example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-solidity"},'contract MyExtension is DaoConstants, IExtension {\n  // Internally tracks deployment under eip-1167 proxy pattern\n  bool public initialized = false;\n\n  // The DAO address that is the owner of this extension\n  DaoRegistry public dao;\n\n  /// @notice Clonable contract must have an empty constructor\n  // constructor() {\n  // }\n\n  enum AclFlag { EXECUTE }\n\n  modifier hasExtensionAccess(AclFlag flag) {\n    require(\n      // 1. Allowed if the extension is calling itself\n      address(this) == msg.sender ||\n        // 2. Allowed if the DAO is calling the extension\n        address(dao) == msg.sender ||\n        // 3. Allowed if the DAO state is in CREATION mode\n        dao.state() == DaoRegistry.DaoState.CREATION ||\n        // 4. Allowed if the sender is a registered adapter\n        dao.hasAdapterAccessToExtension(msg.sender, address(this), uint8(flag)),\n      // 5. Revert message\n      "myExtension::accessDenied"\n    );\n    _;\n  }\n\n  /**\n   * @notice default fallback function to prevent from sending ether to the contract.\n   */\n  receive() external payable {\n    revert("fallback revert");\n  }\n\n  /**\n   * @notice Initialises the extension to be associated with a DAO\n   * @dev Can only be called once\n   * @param creator The DAO\'s creator, who will be an initial member\n   */\n  function initialize(DaoRegistry _dao, address creator) external override {\n    require(!initialized, "executor::already initialized");\n    require(_dao.isMember(creator), "executor::not member");\n    dao = _dao;\n    initialized = true;\n  }\n\n  function myFunctionX(DaoRegistry dao, ...)\n    onlyAdapter(dao)  // checks if the caller is an adapter\n    hasExtensionAccess(AclFlag.EXECUTE) // checks if the caller has access to this function.\n    external {\n      ... impl\n    }\n}\n\n')),(0,i.kt)("p",null,"Since the extension code is ready to be deployed, we need a way to instantiate the extension contract. For that we a CloneFactory pattern for each new extension we created, so it becomes very cheap to deploy new versions of your extensions to different DAOs because the clone happens based on the identify extension address, and all state is fresh, so there is no state sharing between different DAOs."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-solidity"},"contract MyExtensionFactory is CloneFactory, DaoConstants {\n  address public identityAddress;\n\n  event MyExtensionCreated(address myExtensionAddress);\n\n  constructor(address _identityAddress) {\n    identityAddress = _identityAddress;\n  }\n\n  /**\n   * @notice Create and initialize a new instance of MyExtension\n   * @param x1 Any parameter that you may want to set before it gets initialized.\n   */\n  function create(uint256 x1) external {\n    MyExtension myExtension = MyExtension(_createClone(identityAddress));\n    myExtension.setParamX1(x1);\n    emit MyExtensionCreated(address(myExtension));\n  }\n}\n\n")),(0,i.kt)("p",null,"The factory also needs to be declared in the"),(0,i.kt)("h3",{id:"testing-the-new-extension"},"Testing the new Extension"),(0,i.kt)("p",null,"In order to verify if the new extension works properly, one needs to implement the basic test suite, so we can ensure it is actually doing what it was supposed to do."),(0,i.kt)("p",null,"There are several examples of tests that you can check to start building your own. Take a look at the ",(0,i.kt)("strong",{parentName:"p"},(0,i.kt)("a",{parentName:"strong",href:"https://github.com/openlawteam/tribute-contracts/tree/master/test/extensions"},"tests/extenions")),"."),(0,i.kt)("p",null,"The general idea is to create one test suite per extension/contract. And try to cover all the happy paths first, and then add more complex and negative test cases after that."),(0,i.kt)("p",null,"You need to declare the new extension contract to ",(0,i.kt)("strong",{parentName:"p"},(0,i.kt)("a",{parentName:"strong",href:"https://github.com/openlawteam/tribute-contracts/blob/master/utils/ContractUtil.js"},"ContractUtil.js")),", so it can be accessed in the deploy/test environment."),(0,i.kt)("p",null,"In order to speed up the test suites we usually don't create one DAO per test function, but we create the DAO during the suite initialization, and only reset the chain after each test function using the chain snapshot feature. For instance:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},'describe("Extension - ExtensionName", () => {\n  /**\n   * Using the utility function `deployDefaultDao` * to create the DAO before all tests are\n   * executed.\n   * Once the DAO is created you can access the\n   * adapters, extensions, factories, testContracts\n   * and votingHelpers contracts. Use the test global scope\n   * to store them and access it later in the test functions.\n   */\n  before("deploy dao", async () => {\n    const {\n      dao,\n      adapters,\n      extensions,\n      factories,\n      testContracts,\n      votingHelpers,\n    } = await deployDefaultDao({ owner });\n    this.dao = dao;\n    this.adapters = adapters;\n    this.extensions = extensions;\n  });\n\n  /**\n   * Before each test funtion we take a chain snapshot, which\n   * contains the fresh DAO configurations with zero\n   * modifications.\n   */\n  beforeEach(async () => {\n    this.snapshotId = await takeChainSnapshot();\n  });\n\n  /**\n   * After the test function is executed we revert to the\n   * latest chain snapshot took when the DAO was fresh\n   * installed.\n   * With this approach we save time in the DAO creation,\n   * and the test suite runs 10x faster.\n   */\n  afterEach(async () => {\n    await revertChainSnapshot(this.snapshotId);\n  });\n\n  /**\n   * Add a descriptive name to your test function that\n   * covers the use case that you are testing.\n   */\n  it("shoud be possible to ...", async () => {\n    // Access the global scope to read the contracts you may need.\n    const dao = this.dao;\n    const configuration = this.adapters.configuration;\n    const voting = this.adapters.voting;\n\n    // Use openzeppelin test-env to assert results, events,and failures, e.g:\n    expect(value1.toString()).equal("1");\n    expectEvent(tx.receipt, "EventName", {\n      eventArg1: value1,\n      eventArg2: toBN("2"), //value 2\n    });\n    await expectRevert(\n      // Calling the contract function that returns promise\n      configuration.submitProposal(dao.address, "0x1", [key], [], [], {\n        from: owner,\n        gasPrice: toBN("0"),\n      }),\n      "must be an equal number of config keys and values"\n    );\n  });\n});\n')),(0,i.kt)("p",null,"Considering the extension that you are creating is not part of the default set of extensions, you need to declare import it, and the Factory from ",(0,i.kt)("strong",{parentName:"p"},(0,i.kt)("a",{parentName:"strong",href:"https://github.com/openlawteam/tribute-contracts/blob/master/utils/ContractUtil.js"},"ContractUtil.js")),", then deploy both to be able to configure the extension access flags after it is used in the test suite, but it needs to happen ",(0,i.kt)("em",{parentName:"p"},"before")," the DAO is finalized. When the DAO is finalized it means that the DAO initialization has been completed, so any state changes must be done though a proposal, instead of doing it through the deployment phase. Here is a simple example of an extension configurated after its creation, but before the DAO creation is finalized:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},'\nimport { MyExtensionContract, MyExtensionFactory } from \'ContractUtil\';\n\nimport { entry } from \'DeploymentUtil\';\n\ndescribe("Extension - ExtensionName", () => {\n\n  const entryAccessFlag = (contract, flags) => {\n    const values = [\n      flags.EXECUTE,\n    ];\n\n    const acl = entry(values);\n\n    return {\n      id: sha3("n/a"),\n      addr: contract.address,\n      flags: acl,\n    };\n  };\n\n  it("should be possible to...", async () => {\n\n    // Creating the new DAO without finalizing it\n    // So you can add new adapters without going through\n    // a proposal process.\n    const { dao, factories, extensions } = await deployDefaultDao({\n      owner: owner,\n      finalize: false, // Do not finalize the DAO so you can add your extension to it\n    });\n\n    // Create and deploy the identity contract and the factory contract\n    const identityExtension = await MyExtensionContract.new();\n    const myExtensionFactory = await MyExtensionFactory.new(identityExtension.address);\n\n    let x1 = 1;\n    // Create your new extension instance applying the custom parameters\n    await myExtensionFactory.create(x1);\n\n    let pastEvent;\n    // Check if the event was emitted to capture the new extension address\n    while (pastEvent === undefined) {\n      let pastEvents = await myExtensionFactory.getPastEvents();\n      pastEvent = pastEvents[0];\n    }\n    const { myExtensionAddress } = pastEvent.returnValues;\n    // Associate your extension contract to the new address\n    const myExtension = await MyExtensionContract.at(myExtensionAddress);\n\n    // Add the new extension to the DAO, this is possible because the DAO was not finalized yet.\n    await dao.addExtension(sha3("myExtension"), myExtension.address, owner, {\n      from: owner,\n    });\n\n    // If you have an adapter that needs access to your new Extension,\n    // you can set that up using the `daoFactory.configureExtension` function:\n    await factories.daoFactory.configureExtension(\n      dao.address,\n      myExtension.address,\n      [\n        entryAccessFlag(mySampleAdapter.address, {\n          EXECUTE: true,  // the name of the ACL flag, that needs to be enabled.\n          // The flags deleclared here must match the flags declared in your new extension.\n        }),\n      ],\n      { from: owner }\n    );\n\n    // After the extension was configured to access the DAO,\n    // and/or an Extension, you can finalize the DAO creation.\n    await dao.finalizeDao({ from: owner });\n\n    // Start your test here\n    ...\n  });\n});\n')),(0,i.kt)("p",null,"You may need to use an adapter to test your new extension functions that are protected with the ",(0,i.kt)("inlineCode",{parentName:"p"},"adapterOnly")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"hasExtensionAccess")," guards, unless you have defined functions that are not restricted to adapters only."),(0,i.kt)("p",null,"The adapters are known as Utility Adapters, we currently have some of them to access the ",(0,i.kt)("strong",{parentName:"p"},(0,i.kt)("a",{parentName:"strong",href:"/docs/contracts/adapters/utils/bank-adapter"},"Bank"))," and ",(0,i.kt)("strong",{parentName:"p"},(0,i.kt)("a",{parentName:"strong",href:"/docs/contracts/adapters/utils/nft-adapter"},"NFT"))," Extensions, or you can simply modify one of the existing adapters to access your new extensions as defined in the tutorial ",(0,i.kt)("strong",{parentName:"p"},(0,i.kt)("a",{parentName:"strong",href:"/docs/tutorial/adapters/creating-an-adapter#testing-the-new-adapter"},"How to create an adapter")),"."),(0,i.kt)("h3",{id:"adding-documentation"},"Adding documentation"),(0,i.kt)("p",null,"Each extension must provide its own documentation describing what is the use-case it solves, what are the functions and interactions it contains. Examples of that can be found in the existing extensions documentation ",(0,i.kt)("strong",{parentName:"p"},(0,i.kt)("a",{parentName:"strong",href:"/docs/contracts/extensions/bank-extension"},"here")),"."),(0,i.kt)("h3",{id:"done"},"Done"),(0,i.kt)("p",null,"If you have followed all the steps above and created a well tested, documented Extension, please submit a Pull Request to ",(0,i.kt)("strong",{parentName:"p"},(0,i.kt)("a",{parentName:"strong",href:"https://github.com/openlawteam/tribute-contracts/pulls"},"Tribute Contracts")),", so we can review it and provide additional feedback. Thank you!"))}p.isMDXComponent=!0}}]);